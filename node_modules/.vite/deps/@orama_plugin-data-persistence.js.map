{
  "version": 3,
  "sources": ["browser-external:stream", "../../dpack/lib/serialize.js", "../../dpack/lib/serialize-stream.js", "../../dpack/lib/parse.js", "../../dpack/lib/parse-stream.js", "../../dpack/lib/node-encoder.js", "../../dpack/lib/Options.js", "../../dpack/lib/shared.js", "../../dpack/lib/Block.js", "../../dpack/index.js", "../../@msgpack/msgpack/src/utils/utf8.ts", "../../@msgpack/msgpack/src/ExtData.ts", "../../@msgpack/msgpack/src/DecodeError.ts", "../../@msgpack/msgpack/src/utils/int.ts", "../../@msgpack/msgpack/src/timestamp.ts", "../../@msgpack/msgpack/src/ExtensionCodec.ts", "../../@msgpack/msgpack/src/utils/typedArrays.ts", "../../@msgpack/msgpack/src/Encoder.ts", "../../@msgpack/msgpack/src/encode.ts", "../../@msgpack/msgpack/src/utils/prettyByte.ts", "../../@msgpack/msgpack/src/CachedKeyDecoder.ts", "../../@msgpack/msgpack/src/Decoder.ts", "../../@msgpack/msgpack/src/decode.ts", "../../@orama/plugin-data-persistence/src/index.ts", "../../@orama/plugin-data-persistence/src/errors.ts", "../../@orama/plugin-data-persistence/src/utils.ts", "../../seqproto/dist/esm/index.js", "../../@orama/plugin-data-persistence/src/seqproto.ts"],
  "sourcesContent": ["module.exports = Object.create(new Proxy({}, {\n  get(_, key) {\n    if (\n      key !== '__esModule' &&\n      key !== '__proto__' &&\n      key !== 'constructor' &&\n      key !== 'splice'\n    ) {\n      console.warn(`Module \"stream\" has been externalized for browser compatibility. Cannot access \"stream.${key}\" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`)\n    }\n  }\n}))", "\"use strict\"\r\n// these are the codes that are used to determine the rudimentary type of numbers\r\nvar PROPERTY_CODE = 0\r\nvar TYPE_CODE = 3\r\nvar STRING_CODE = 2\r\nvar NUMBER_CODE = 1\r\nvar SEQUENCE_CODE = 7\r\n\r\n// constant codes\r\nvar NULL = 0 // p\r\nvar FALSE = 3 // s\r\nvar TRUE = 4 // t\r\nvar UNDEFINED = 5 // u\r\n\r\n// these are the starting codes (structures also use this space) for complete types\r\nvar DEFAULT_TYPE = 6\r\nvar ARRAY_TYPE = 7\r\nvar REFERENCING_TYPE = 8\r\nvar NUMBER_TYPE = 9\r\nvar EXTENSIONS = 10\r\nvar METADATA_TYPE = 11\r\nvar COPY_PROPERTY = 12  // for defining a typed object without returning the value\r\nvar REFERENCING_POSITION = 13\r\nvar TYPE_DEFINITION = 14  // for defining a typed object without returning the value\r\n\r\nvar ERROR_METADATA = 500\r\n\r\n// sequence codes\r\nvar OPEN_SEQUENCE = 12 // <\r\nvar PARTIAL_DEFERRED_REFERENCE = 12 // <\r\nvar END_SEQUENCE = 14 // >\r\nvar DEFERRED_REFERENCE = 15 // ?\r\nvar nextId = 1\r\nvar iteratorSymbol = typeof Symbol !== 'undefined' ? Symbol.iterator : '__iterator_symbol__'\r\n\r\nfunction createSerializer(options) {\r\n\tif (!options)\r\n\t\toptions = {}\r\n\tvar extendedTypes = options.converterByConstructor\r\n\tif (!extendedTypes) {\r\n\t\textendedTypes = new Map()\r\n\t}\r\n\textendedTypes.set(Map, {\r\n\t\tname: 'Map',\r\n\t\ttoValue: writeMap\r\n\t})\r\n\textendedTypes.set(Set, {\r\n\t\tname: 'Set',\r\n\t\ttoValue: writeSet\r\n\t})\r\n\textendedTypes.set(Date, {\r\n\t\tname: 'Date',\r\n\t\ttoValue: writeDate\r\n\t})\r\n\tvar avoidShareUpdate = options.outlet || options.avoidShareUpdate\r\n\tvar charEncoder = (typeof global != 'undefined' && global.Buffer && !(options && options.encoding === 'utf16le')) ? exports.nodeCharEncoder(options) : browserCharEncoder(options)\r\n\tvar writeString = charEncoder.writeString\r\n\tvar writeToken = charEncoder.writeToken\r\n\tvar startSequence = charEncoder.startSequence\r\n\tvar endSequence = charEncoder.endSequence\r\n\tvar writeBuffer = charEncoder.writeBuffer\r\n\tvar forProperty = options.forProperty\r\n\tvar propertyUsed\r\n\tvar valueUsed\r\n\tif (options.shared) {\r\n\t\tpropertyUsed = options.shared.propertyUsed\r\n\t\tvalueUsed = options.shared.propertyUsed\r\n\t}\r\n\tvar pendingEncodings = []\r\n\tvar nextPropertyIndex = 8\r\n\tvar property\r\n\tvar bufferSymbol = exports.bufferSymbol || '_bufferSymbol_'\r\n\tvar targetSymbol = exports.targetSymbol || '_targetSymbol_'\r\n\tvar propertyComparisons = 0\r\n\tvar serializerId = nextId++\r\n\r\n\tvar writers = [\r\n\t\t0, 1, 2, 3, 4 , 5,\r\n\t\twriteAsDefault,\r\n\t\twriteAsArray,\r\n\t\twriteAsReferencing,\r\n\t\twriteAsNumber,\r\n\t\twriteOnlyNull\r\n\t]\r\n\t// write a rudimentary number\r\n\tfunction writeNumber(number) {\r\n\t\twriteToken(NUMBER_CODE, number)\r\n\t}\r\n\t// write a rudimentary string\r\n\tfunction writeInlineString(string) {\r\n\t\twriteToken(STRING_CODE, string.length)\r\n\t\twriteString(string)\r\n\t}\r\n\r\n\t// writing any value in referencing serialization type mode\r\n\tfunction writeAsReferencing(value) {\r\n\t\tvar type, values = property.values\r\n\t\tif (values) {\r\n\t\t\tif (values.resetTo > -1 && values.serializer !== serializerId) {\r\n\t\t\t\t// if this is a shared values, need to reset on each serialization\r\n\t\t\t\tvalues.serializer = serializerId\r\n\t\t\t\tif (values.resetTo < values.length)\r\n\t\t\t\t\tvalues.length = values.resetTo\r\n\t\t\t\twriteToken(TYPE_CODE, REFERENCING_POSITION)\r\n\t\t\t\twriteToken(NUMBER_CODE, values.resetTo)\r\n\t\t\t}\r\n\t\t\tvar reference = values.indexOf(value)\r\n\t\t\tif (reference > -1) {\r\n\t\t\t\treturn writeNumber(reference)\r\n\t\t\t}\r\n\t\t}\r\n\t\tif ((type = typeof value) === 'string' || type ==='object' && value) {\r\n\t\t\tif (property.writeSharedValue) {\r\n\t\t\t\tif (property.writeSharedValue(value, writeToken, serializerId))\r\n\t\t\t\t\treturn\r\n\t\t\t} else if (values) {\r\n\t\t\t\tvar index = values.length\r\n\t\t\t\tif (index < 12)\r\n\t\t\t\t\tvalues[index] = value\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (type === 'string') {\r\n\t\t\twriteInlineString(value)\r\n\t\t} else {\r\n\t\t\twriteAsDefault(value)\r\n\t\t}\r\n\t}\r\n\r\n\t// writing any value in number serialization type mode\r\n\tfunction writeAsNumber(number) {\r\n\t\tvar type = typeof number\r\n\t\tif (type === 'number') {\r\n\t\t\tif (number >>> 0 === number || (number > 0 && number < 0x400000000000 && number % 1 === 0)) {\r\n\t\t\t\t// 46 bit unsigned integer\r\n\t\t\t\twriteToken(NUMBER_CODE, number)\r\n\t\t\t} else {\r\n\t\t\t\t// decimal number serialized as a string\r\n\t\t\t\tvar asString = number.toString()\r\n\t\t\t\twriteInlineString(asString)\r\n\t\t\t}\r\n\t\t} else if (type === 'object') {\r\n\t\t\twriteAsDefault(number)\r\n\t\t} else {\r\n\t\t\twriteTypedValue(number)\r\n\t\t}\r\n\t}\r\n\r\n\tfunction writeTypedValue(value) {\r\n\t\tif (value === null)\r\n\t\t\twriteToken(TYPE_CODE, NULL)\r\n\t\telse if (value === false)\r\n\t\t\twriteToken(TYPE_CODE, FALSE)\r\n\t\telse if (value === true)\r\n\t\t\twriteToken(TYPE_CODE, TRUE)\r\n\t\telse if (value === undefined)\r\n\t\t\twriteToken(TYPE_CODE, UNDEFINED)\r\n\t\telse {\r\n\t\t\twriteTypedNonConstant(value)\r\n\t\t}\r\n\t}\r\n\r\n\tfunction writeTypedNonConstant(value) {\r\n\t\tvar type = typeof value\r\n\t\tvar extendedType\r\n\t\tif (type === 'object') {\r\n\t\t\tif (value) {\r\n\t\t\t\tvar constructor = value.constructor\r\n\t\t\t\tif (constructor === Object) {\r\n\t\t\t\t\t// leave type as is\r\n\t\t\t\t} else if (constructor === Array) {\r\n\t\t\t\t\ttype = 'array'\r\n\t\t\t\t} else {\r\n\t\t\t\t\textendedType = extendedTypes.get(constructor)\r\n\t\t\t\t\tif (extendedType && extendedType.toValue) {\r\n\t\t\t\t\t\tvalue = extendedType.toValue(value)\r\n\t\t\t\t\t\ttype = typeof value // go through the same logic adjustment here\r\n\t\t\t\t\t\tif (value && type === 'object' && value.constructor === Array) {\r\n\t\t\t\t\t\t\ttype = 'array'\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (property.type === type) {\r\n\t\t\t\t\t\t\t// if we are the right type after doing the conversion, go back to the original property to serialize\r\n\t\t\t\t\t\t\tif (property.extendedType !== extendedType) {\r\n\t\t\t\t\t\t\t\tproperty.extendedType = extendedType\r\n\t\t\t\t\t\t\t\twriteToken(TYPE_CODE, METADATA_TYPE)\r\n\t\t\t\t\t\t\t\twriteInlineString(extendedType.name)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn writers[property.code](value)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\textendedType = false\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t} else { // null\r\n\t\t\t\ttype = 'undefined' // treat null as same type as undefined, both constants\r\n\t\t\t}\r\n\t\t} else if (type === 'boolean') {\r\n\t\t\ttype = 'undefined'\r\n\t\t} else if (type === 'function') {\r\n\t\t\tvalue = value.toString()\r\n\t\t\ttype = 'string'\r\n\t\t}\r\n\t\tproperty = writeProperty(null, type, extendedType)\r\n\t\twriters[property.code](value)\r\n\t}\r\n\r\n\tfunction writeOnlyNull() {\r\n\t\twriteToken(TYPE_CODE, NULL)\r\n\t}\r\n\r\n\t// writing any value in default serialization type mode\r\n\tfunction writeAsDefault(value, isRoot) {\r\n\t\tvar type = typeof value\r\n\t\tif (type === 'object') {\r\n\t\t\tif (!value) {\r\n\t\t\t\treturn writeToken(TYPE_CODE, NULL)\r\n\t\t\t}\r\n\t\t\t// else continue with the object code\r\n\t\t} else if (type === 'string') {\r\n\t\t\treturn writeInlineString(value)\r\n\t\t} else if (type === 'number' && (value >>> 0 === value || (value > 0 && value < 0x400000000000 && value % 1 === 0))) {\r\n\t\t\t// 46 bit unsigned integer\r\n\t\t\treturn writeToken(NUMBER_CODE, value)\r\n\t\t} else {\r\n\t\t\treturn writeTypedValue(value)\r\n\t\t}\r\n\t\tvar object = value\r\n\t\tvar constructor = object.constructor\r\n\t\tvar notPlainObject\r\n\t\tif (object[targetSymbol]) {\r\n\t\t\treturn writeBlockReference(value)\r\n\t\t} else if (constructor === Object) {\r\n\t\t\tnotPlainObject = false\r\n\t\t} else if (constructor === Array) {\r\n\t\t\tproperty = writeProperty(property.key, 'array')\r\n\t\t\treturn writers[property.code](value)\r\n\t\t} else {\r\n\t\t\tif (object.then) {\r\n\t\t\t\treturn writeBlockReference(value)\r\n\t\t\t}\r\n\t\t\textendedType = extendedTypes.get(constructor)\r\n\t\t\tif (extendedType) {\r\n\t\t\t\tif (extendedType.toValue) {\r\n\t\t\t\t\treturn writeTypedValue(object)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif (object[iteratorSymbol]) {\r\n\t\t\t\t\tproperty = writeProperty(property.key, 'array')\r\n\t\t\t\t\treturn writeAsIterable(object, isRoot)\r\n\t\t\t\t}\r\n\t\t\t\textendedTypes.set(constructor, extendedType = {\r\n\t\t\t\t\tname: constructor.name\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\tif (property.constructs !== constructor) {\r\n\t\t\t\twriteToken(TYPE_CODE, METADATA_TYPE)\r\n\t\t\t\twriteInlineString(extendedType.name)\r\n\t\t\t\tproperty.constructs = constructor\r\n\t\t\t}\r\n\t\t\tnotPlainObject = true\r\n\t\t}\r\n\t\tvar thisProperty = property\r\n\t\tif (thisProperty.resetTo < thisProperty.length && thisProperty.serializer != serializerId) {\r\n\t\t\tthisProperty.length = thisProperty.resetTo\r\n\t\t\tthisProperty.serializer = serializerId\r\n\t\t}\r\n\t\tstartSequence()\r\n\t\tvar i = 0\r\n\t\t//var sparse = false // densely packed property references can be searched more quickly\r\n\t\tvar resumeIndex = -2 // -2 denotes densely packed property references \r\n\t\tvar propertyIndex = 0\r\n\t\tfor (var key in object) {\r\n\t\t\tif (notPlainObject && !object.hasOwnProperty(key))\r\n\t\t\t\tcontinue\r\n\t\t\tvar value = object[key]\r\n\t\t\ttype = typeof value\r\n\t\t\tproperty = thisProperty[propertyIndex]\r\n\t\t\tvar constructor\r\n\t\t\tvar extendedType = false\r\n\t\t\tif (type === 'object') {\r\n\t\t\t\tif (value) {\r\n\t\t\t\t\tconstructor = value.constructor\r\n\t\t\t\t\tif (constructor === Object) {\r\n\t\t\t\t\t\t// leave type as is\r\n\t\t\t\t\t} else if (constructor === Array) {\r\n\t\t\t\t\t\ttype = 'array'\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\textendedType = extendedTypes.get(constructor)\r\n\t\t\t\t\t\tif (extendedType && extendedType.toValue) {\r\n\t\t\t\t\t\t\tvalue = extendedType.toValue(value)\r\n\t\t\t\t\t\t\ttype = typeof value // go through the same logic adjustment here\r\n\t\t\t\t\t\t\tif (value && type === 'object' && value.constructor === Array) {\r\n\t\t\t\t\t\t\t\ttype = 'array'\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else if (value[iteratorSymbol] && !value.then) {\r\n\t\t\t\t\t\t\ttype = 'array'\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\textendedType = false\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else { // null\r\n\t\t\t\t\ttype = 'undefined' // treat null as same type as undefined (and boolean), both constants that can go in any type\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!property || property.key !== key ||\r\n\t\t\t\t(property.type !== type && type !== 'boolean' && type !== 'undefined' && !(type === 'string' && property.type !== 'number')) ||\r\n\t\t\t\t(extendedType && property.extendedType !== constructor)) {\r\n\t\t\t\tvar lastPropertyIndex = propertyIndex\r\n\t\t\t\t// property doesn't match, search for it through existing properties\r\n\t\t\t\t// note that we are starting at the current propertyIndex, so this makes the assumption that\r\n\t\t\t\t// properties are rarely ever swapped, so possible property slots are always forward\r\n\t\t\t\tif (resumeIndex > -2)\r\n\t\t\t\t\tpropertyIndex = resumeIndex\r\n\t\t\t\tdo {\r\n\t\t\t\t\tproperty = thisProperty[++propertyIndex]\r\n\t\t\t\t} while(property && (property.key !== key ||\r\n\t\t\t\t\t\t(property.type !== type && type !== 'boolean' && type !== 'undefined' && !(type === 'string' && property.type !== 'number')) ||\r\n\t\t\t\t\t\t(extendedType && property.extendedType !== constructor)))\r\n\t\t\t\tif (property) {\r\n\t\t\t\t\t// found a match, reference it\r\n\t\t\t\t\twriteToken(PROPERTY_CODE, propertyIndex)\r\n\t\t\t\t\tif (resumeIndex === -2) {\r\n\t\t\t\t\t\tresumeIndex = lastPropertyIndex - 1\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (thisProperty.getProperty) {\r\n\t\t\t\t\t// a shared property, let it allocate ids\r\n\t\t\t\t\tproperty = thisProperty.getProperty(value, key, type, extendedType, writeProperty, writeToken, lastPropertyIndex)\r\n\t\t\t\t\tpropertyIndex = property.index\r\n\t\t\t\t\tif (lastPropertyIndex !== propertyIndex && resumeIndex === -2) {\r\n\t\t\t\t\t\tresumeIndex = lastPropertyIndex - 1\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (lastPropertyIndex === thisProperty.length) {\r\n\t\t\t\t\t\tpropertyIndex = lastPropertyIndex\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\twriteToken(PROPERTY_CODE, propertyIndex = thisProperty.length)\r\n\t\t\t\t\t\tif (resumeIndex === -2) {\r\n\t\t\t\t\t\t\tresumeIndex = lastPropertyIndex - 1\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (propertyIndex < thisProperty.resetTo) {\r\n\t\t\t\t\t\tdebugger\r\n\t\t\t\t\t\tthrow new Error('overwriting frozen property')\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tproperty = thisProperty[propertyIndex] = writeProperty(key, type, extendedType)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (propertyUsed)\r\n\t\t\t\tpropertyUsed(property, object, serializerId, i)\r\n//\t\t\tif (property.resumeIndex) // TODO: add a flag to enable this when property ordering can be assumed\r\n//\t\t\t\tresumeIndex = property.resumeIndex\r\n\t\t\tvar code = property.code\r\n\t\t\tif (code > 7) {\r\n\t\t\t\tif (code === 8)\r\n\t\t\t\t\twriteAsReferencing(value)\r\n\t\t\t\telse\r\n\t\t\t\t\twriteAsNumber(value)\r\n\t\t\t} else {\r\n\t\t\t\tif (code === 6) \r\n\t\t\t\t\twriteAsDefault(value)\r\n\t\t\t\telse\r\n\t\t\t\t\twriteAsArray(value)\r\n\t\t\t}\r\n\t\t\tpropertyIndex++\r\n\t\t\ti++\r\n\t\t}\r\n\t\tproperty = thisProperty\r\n\t\tendSequence(i)\r\n\t}\r\n\r\n\tfunction writeProperty(key, type, extendedType) {\r\n\t\tvar property\r\n\t\tproperty = []\r\n\t\tproperty.key = key\r\n\t\tproperty.type = type\r\n\t\tif (type === 'string') {\r\n\t\t\twriteToken(TYPE_CODE, REFERENCING_TYPE)\r\n\t\t\tproperty.values = []\r\n\t\t\tproperty.code = REFERENCING_TYPE\r\n\t\t} else if (type === 'number') {\r\n\t\t\twriteToken(TYPE_CODE, NUMBER_TYPE)\r\n\t\t\tproperty.code = NUMBER_TYPE\r\n\t\t} else if (type === 'object') {\r\n\t\t\twriteToken(TYPE_CODE, DEFAULT_TYPE)\r\n\t\t\tproperty.code = DEFAULT_TYPE\r\n\t\t} else if (type === 'array') {\r\n\t\t\twriteToken(TYPE_CODE, ARRAY_TYPE)\r\n\t\t\tproperty.code = ARRAY_TYPE\r\n\t\t} else if (type === 'boolean' || type === 'undefined') {\r\n\t\t\tproperty.type = 'object'\r\n\t\t\twriteToken(TYPE_CODE, DEFAULT_TYPE)\r\n\t\t\tproperty.code = DEFAULT_TYPE\r\n\t\t} else {\r\n\t\t\twriteToken(TYPE_CODE, DEFAULT_TYPE)\r\n\t\t\tproperty.code = 10\r\n\t\t\tconsole.error('Unable to write value of type ' + type)\r\n\t\t}\r\n\r\n\t\tif (typeof key === 'string') {\r\n\t\t\twriteInlineString(key)\r\n\t\t} else if (!(key === null && (type === 'object' || type === 'array'))) { // if key is null followed by sequence, we can elide the key\r\n\t\t\twriteAsDefault(key)\r\n\t\t}\r\n\t\tif (extendedType) {\r\n\t\t\tproperty.extendedType = extendedType\r\n\t\t\twriteToken(TYPE_CODE, METADATA_TYPE)\r\n\t\t\twriteInlineString(extendedType.name)\r\n\t\t}\r\n\t\treturn property\r\n\t}\r\n\r\n\tfunction writeAsIterable(iterable, isRoot, iterator) {\r\n\t\t// TODO: With top level iterables we could pause for back-pressure\r\n\t\ttry {\r\n\t\t\tif (!iterator) {\r\n\t\t\t\twriteToken(SEQUENCE_CODE, OPEN_SEQUENCE)\r\n\t\t\t\titerator = iterable[iteratorSymbol]()\r\n\t\t\t}\r\n\t\t\tvar arrayProperty = property\r\n\t\t\tproperty = arrayProperty.child || (arrayProperty.child = arrayProperty) // set the current property to the child property\r\n\t\t\t// write out the elements\r\n\t\t\tvar result\r\n\t\t\twhile(!(result = iterator.next()).done) {\r\n\t\t\t\twriters[property.code](result.value, arrayProperty)\r\n\t\t\t\tif (isRoot && charEncoder.hasWritten) {\r\n\t\t\t\t\tcharEncoder.hasWritten = false // reset this property\r\n\t\t\t\t\tproperty = arrayProperty // restore current property\r\n\t\t\t\t\tpendingEncodings.unshift({\r\n\t\t\t\t\t\tthen: function(callback) {\r\n\t\t\t\t\t\t\twriteAsIterable(null, true, iterator)\r\n\t\t\t\t\t\t\treturn callback()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} catch(error) {\r\n\t\t\twriteToken(TYPE_CODE, METADATA_TYPE)\r\n\t\t\twriteToken(NUMBER_CODE, ERROR_METADATA)\r\n\t\t\twriteAsDefault(Object.assign(new ((typeof error == 'object' && error) ? error.constructor : Error)(), {\r\n\t\t\t\tname: error && error.name, // make these enumerable so they will serialize\r\n\t\t\t\tmessage: error && error.message || error\r\n\t\t\t}))\r\n\t\t\tthrow error\r\n\t\t}\r\n\t\tif (property !== arrayProperty.child) {\r\n\t\t\t// TODO: This really needs to happen immediately when a property changes, to match the parsing behavior\r\n\t\t\tarrayProperty.child = property\r\n\t\t}\r\n\t\tproperty = arrayProperty // restore current property\r\n\t\twriteToken(SEQUENCE_CODE, END_SEQUENCE) // end sequence\r\n\t}\r\n\r\n\tfunction writeAsArray(array) {\r\n\t\tif (!array) {\r\n\t\t\twriteTypedValue(array)\r\n\t\t} else if (array[targetSymbol]) {\r\n\t\t\treturn writeBlockReference(array)\r\n\t\t} else if (array.constructor === Array) { // check to make sure it is an array\r\n\t\t\tvar length = array.length\r\n\t\t\tvar needsClosing\r\n\t\t\tif (length > 11) {\r\n\t\t\t\twriteToken(SEQUENCE_CODE, OPEN_SEQUENCE) // start sequence <\r\n\t\t\t\tneedsClosing = true\r\n\t\t\t} else {\r\n\t\t\t\twriteToken(SEQUENCE_CODE, length) // write out the header token\r\n\t\t\t}\r\n\t\t\tvar arrayProperty = property\r\n\t\t\tproperty = arrayProperty[0] // set the current property to the child property\r\n\t\t\t// check to see if needs to be reset before starting\r\n\t\t\tif (arrayProperty.resetTo < arrayProperty.length && arrayProperty.serializer != serializerId) {\r\n\t\t\t\tarrayProperty.length = arrayProperty.resetTo\r\n\t\t\t\tarrayProperty.serializer = serializerId\r\n\t\t\t}\r\n\t\t\tvar propertyIndex = 0\r\n\t\t\t// write out the elements\r\n\t\t\tfor (var i = 0; i < length; i++) {\r\n\t\t\t\tvar value = array[i]\r\n\t\t\t\tvar type = typeof value\r\n\t\t\t\tif (type === 'object') {\r\n\t\t\t\t\tif (value) {\r\n\t\t\t\t\t\tvar constructor = value.constructor\r\n\t\t\t\t\t\tif (constructor === Object) {\r\n\t\t\t\t\t\t\t// leave type as is\r\n\t\t\t\t\t\t} else if (constructor === Array) {\r\n\t\t\t\t\t\t\ttype = 'array'\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tvar extendedType = extendedTypes.get(constructor)\r\n\t\t\t\t\t\t\tif (extendedType && extendedType.toValue) {\r\n\t\t\t\t\t\t\t\tvalue = extendedType.toValue(value)\r\n\t\t\t\t\t\t\t\ttype = typeof value // go through the same logic adjustment here\r\n\t\t\t\t\t\t\t\tif (value && type === 'object' && value.constructor === Array) {\r\n\t\t\t\t\t\t\t\t\ttype = 'array'\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\textendedType = false\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else { // null\r\n\t\t\t\t\t\ttype = 'undefined' // treat null as same type as undefined, both constants\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (!property) {\r\n\t\t\t\t\tif (arrayProperty.getProperty) {\r\n\t\t\t\t\t\t// a shared property\r\n\t\t\t\t\t\tproperty = arrayProperty.getProperty(value, null, type, extendedType, writeProperty, writeToken, 0)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (type === 'string' || type === 'number' || type === 'array')\r\n\t\t\t\t\t\t\tproperty = writeProperty(null, type, extendedType)\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t// default doesn't have to be written\r\n\t\t\t\t\t\t\tproperty = []\r\n\t\t\t\t\t\t\tproperty.type = type\r\n\t\t\t\t\t\t\tproperty.key = null\r\n\t\t\t\t\t\t\tproperty.code = DEFAULT_TYPE\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tarrayProperty[0] = property\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if ((property.type !== type && type !== 'boolean' && type !== 'undefined' && !(type === 'string' && property.type !== 'number')) ||\r\n\t\t\t\t\t(extendedType && property.extendedType !== constructor)) {\r\n\t\t\t\t\tpropertyIndex = -1\r\n\t\t\t\t\tdo {\r\n\t\t\t\t\t\tproperty = arrayProperty[++propertyIndex]\r\n\t\t\t\t\t} while(property && ((property.type !== type && type !== 'boolean' && type !== 'undefined' && !(type === 'string' && property.type !== 'number')) ||\r\n\t\t\t\t\t\t\t(extendedType && property.extendedType !== constructor)))\r\n\t\t\t\t\tif (property) {\r\n\t\t\t\t\t\twriteToken(PROPERTY_CODE, propertyIndex)\r\n\t\t\t\t\t} else if (arrayProperty.getProperty) {\r\n\t\t\t\t\t\t// a shared property\r\n\t\t\t\t\t\tproperty = arrayProperty.getProperty(value, null, type, extendedType, writeProperty, writeToken, -1)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\twriteToken(PROPERTY_CODE, propertyIndex)\r\n\t\t\t\t\t\tproperty = writeProperty(null, type, extendedType)\r\n\t\t\t\t\t\tarrayProperty[propertyIndex] = property\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (propertyUsed)\r\n\t\t\t\t\tpropertyUsed(property, array, serializerId, i)\r\n\t\t\t\tvar code = property.code\r\n\t\t\t\tif (code > 7) {\r\n\t\t\t\t\tif (code === 8)\r\n\t\t\t\t\t\twriteAsReferencing(value)\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\twriteAsNumber(value)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (code === 6) \r\n\t\t\t\t\t\twriteAsDefault(value)\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\twriteAsArray(value)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (needsClosing) {\r\n\t\t\t\twriteToken(SEQUENCE_CODE, END_SEQUENCE) // end sequence\r\n\t\t\t}\r\n\t\t\tproperty = arrayProperty // restore current property\r\n\t\t} else if (typeof array == 'object' && array[iteratorSymbol]) {\r\n\t\t\treturn writeAsIterable(array)\r\n\t\t} else if (type === 'string') {\r\n\t\t\treturn writeInlineString(value)\r\n\t\t} else if (type === 'number' && (value >>> 0 === value || (value > 0 && value < 0x400000000000 && value % 1 === 0))) {\r\n\t\t\treturn writeToken(NUMBER_CODE, value)\r\n\t\t} else { // bail to default mode behavior\r\n\t\t\twriteTypedValue(array)\r\n\t\t}\r\n\t}\r\n\r\n\tvar blockProperty\r\n\r\n\tfunction writeBlockReference(block, writer) {\r\n\t\twriteToken(SEQUENCE_CODE, DEFERRED_REFERENCE)\r\n\t\tvar blockProperty = property\r\n\t\tvar lazyPromise = block[targetSymbol] ? {\r\n\t\t\tthen: then\r\n\t\t} : {\r\n\t\t\tthen: function(callback) {\r\n\t\t\t\treturn block.then(function(value) {\r\n\t\t\t\t\tblock = value\r\n\t\t\t\t\tthen(callback)\r\n\t\t\t\t}, function(error) {\r\n\t\t\t\t\tblock = Object.assign(new ((typeof error == 'object' && error) ? error.constructor : Error)(), {\r\n\t\t\t\t\t\tname: error && error.name, // make these enumerable so they will serialize\r\n\t\t\t\t\t\tmessage: error && error.message || error\r\n\t\t\t\t\t})\r\n\t\t\t\t\tif (!blockProperty.upgrade) {\r\n\t\t\t\t\t\twriteToken(TYPE_CODE, METADATA_TYPE)\r\n\t\t\t\t\t\twriteToken(NUMBER_CODE, ERROR_METADATA)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthen(callback)\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunction then(callback) {\r\n\t\t\tif (options.forBlock && block) {\r\n\t\t\t\t// this is used by the sizeTable serializer to record the size of each block\r\n\t\t\t\toptions.forBlock(block, blockProperty)\r\n\t\t\t} else {\r\n\t\t\t\tvar buffer = block && block[bufferSymbol] && block[bufferSymbol](blockProperty)\r\n\t\t\t\tif (buffer) {\r\n\t\t\t\t\twriteBuffer(buffer)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tproperty = blockProperty\r\n\t\t\t\t\tvar lastPendingEncodings = pendingEncodings\r\n\t\t\t\t\tpendingEncodings = [] // record any nested pending encoding separately\r\n\t\t\t\t\twriteAsDefault(block, true) // write it out as the next block\r\n\t\t\t\t\tlastPendingEncodings.unshift.apply(lastPendingEncodings, pendingEncodings) // and splice them in front\r\n\t\t\t\t\tpendingEncodings = lastPendingEncodings\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcallback()\r\n\t\t}\r\n\t\tpendingEncodings.push(lazyPromise)\r\n\t}\r\n\r\n\tvar serializer = {\r\n\t\tserialize: function(value, sharedProperty) {\r\n\t\t\tvar buffer = value && value[bufferSymbol] && value[bufferSymbol](sharedProperty)\r\n\r\n\t\t\tif (buffer) {\r\n\t\t\t\tcharEncoder.writeBuffer(buffer)\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tif (sharedProperty) {\r\n\t\t\t\tproperty = sharedProperty\r\n\t\t\t\twriters[property.code](value)\r\n\t\t\t} else {\r\n\t\t\t\tproperty = []\r\n\t\t\t\tproperty.key = null\r\n\t\t\t\twriteAsDefault(value, true)\r\n\t\t\t}\r\n\t\t},\r\n\t\tgetSerialized: function() {\r\n\t\t\tif (pendingEncodings.length > 0) {\r\n\t\t\t\tvar promises = []\r\n\t\t\t\twhile (pendingEncodings.length > 0) {\r\n\t\t\t\t\tvar finished = false\r\n\t\t\t\t\tvar promise = pendingEncodings.shift().then(function() {\r\n\t\t\t\t\t\tfinished = true\r\n\t\t\t\t\t})\r\n\t\t\t\t\tif (!finished) {\r\n\t\t\t\t\t\tpromises.push(promise)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (promises.length > 0) {\r\n\t\t\t\t\treturn Promise.all(promises).then(function() {\r\n\t\t\t\t\t\treturn serializer.getSerialized()\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (options && options.encoding === 'utf16le') {\r\n\t\t\t\treturn Buffer.from(charEncoder.getSerialized(), 'utf16le')\r\n\t\t\t}\r\n\t\t\treturn charEncoder.getSerialized()\r\n\t\t},\r\n\t\tflush: charEncoder.flush,\r\n\t\tsetOffset: charEncoder.setOffset,\r\n\t\tfinish: charEncoder.finish,\r\n\t\tpendingEncodings: pendingEncodings,\r\n\t\tgetWriters: function() {\r\n\t\t\treturn {\r\n\t\t\t\twriteProperty: writeProperty,\r\n\t\t\t\twriteToken: writeToken,\r\n\t\t\t\twriteAsDefault: writeAsDefault,\r\n\t\t\t\twriteBuffer: writeBuffer\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn serializer\r\n}\r\nfunction serialize(value, options) {\r\n\tvar serializer = createSerializer(options)\r\n\tvar sharedProperty = options && options.shared\r\n\tvar buffer\r\n\tif (sharedProperty && sharedProperty.startWrite) {\r\n\t\t// record the start of each write\r\n\t\tsharedProperty.startWrite(options.avoidShareUpdate, value)\r\n\t}\r\n\tserializer.serialize(value, sharedProperty)\r\n\tbuffer = serializer.getSerialized()\r\n\tif (sharedProperty && sharedProperty.endWrite) {\r\n\t\t// record the end of each write\r\n\t\tsharedProperty.endWrite(options.avoidShareUpdate, value)\r\n\t}\r\n\tif (serializer.finish)\r\n\t\tserializer.finish()\r\n\tvar sizeTable = value && value[exports.sizeTableSymbol]\r\n\tif (sizeTable) {\r\n\t\tbuffer.sizeTable = sizeTable\r\n\t}\r\n\r\n\tif (options && options.lazy) {\r\n\t\treturn Buffer.concat([value[exports.sizeTableSymbol], buffer])\r\n\t}\r\n\treturn buffer\r\n}\r\nexports.serialize = serialize\r\nexports.createSerializer = createSerializer\r\nfunction browserCharEncoder() {\r\n\tvar serialized = ''\r\n\tfunction writeToken(type, number) {\r\n\t\tvar serializedToken\r\n\t\tif (number < 0x10) { // 4 bits of number\r\n\t\t\tserializedToken = String.fromCharCode(((type << 4) | number) ^ 0x40)\r\n\t\t} else if (number < 0x400) { // 10 bits of number\r\n\t\t\tserializedToken = String.fromCharCode(\r\n\t\t\t\t(type << 4) + (number >>> 6),\r\n\t\t\t\t(number & 0x3f) + 0x40)\r\n\t\t} else if (number < 0x10000) { // 16 bits of number\r\n\t\t\tserializedToken = String.fromCharCode(\r\n\t\t\t\t(type << 4) + (number >>> 12),\r\n\t\t\t\t(number >>> 6) & 0x3f,\r\n\t\t\t\t(number & 0x3f) + 0x40)\r\n\t\t} else if (number < 0x400000) { // 22 bits of number\r\n\t\t\tserializedToken = String.fromCharCode(\r\n\t\t\t\t(type << 4) + (number >>> 18),\r\n\t\t\t\t(number >>> 12) & 0x3f,\r\n\t\t\t\t(number >>> 6) & 0x3f,\r\n\t\t\t\t(number & 0x3f) + 0x40)\r\n\t\t} else if (number < 0x10000000) { // 28 bits of number\r\n\t\t\tserializedToken = String.fromCharCode(\r\n\t\t\t\t(type << 4) + (number >>> 24),\r\n\t\t\t\t(number >>> 18) & 0x3f,\r\n\t\t\t\t(number >>> 12) & 0x3f,\r\n\t\t\t\t(number >>> 6) & 0x3f,\r\n\t\t\t\t(number & 0x3f) + 0x40)\r\n\t\t} else if (number < 0x100000000) { // 32 bits of number\r\n\t\t\tserializedToken = String.fromCharCode(\r\n\t\t\t\t(type << 4) + (number >>> 30),\r\n\t\t\t\t(number >>> 24) & 0x3f,\r\n\t\t\t\t(number >>> 18) & 0x3f,\r\n\t\t\t\t(number >>> 12) & 0x3f,\r\n\t\t\t\t(number >>> 6) & 0x3f,\r\n\t\t\t\t(number & 0x3f) + 0x40)\r\n\t\t} else if (number < 0x400000000) { // 34 bits of number\r\n\t\t\tserializedToken = String.fromCharCode(\r\n\t\t\t\t(type << 4) + (number / 0x40000000 >>> 0),\r\n\t\t\t\t(number >>> 24) & 0x3f,\r\n\t\t\t\t(number >>> 18) & 0x3f,\r\n\t\t\t\t(number >>> 12) & 0x3f,\r\n\t\t\t\t(number >>> 6) & 0x3f,\r\n\t\t\t\t(number & 0x3f) + 0x40)\r\n\t\t} else if (number < 0x10000000000) { // 40 bits of number\r\n\t\t\tserializedToken = String.fromCharCode(\r\n\t\t\t\t(type << 4) + (number / 0x1000000000 >>> 0),\r\n\t\t\t\t(number / 0x40000000) & 0x3f,\r\n\t\t\t\t(number >>> 24) & 0x3f,\r\n\t\t\t\t(number >>> 18) & 0x3f,\r\n\t\t\t\t(number >>> 12) & 0x3f,\r\n\t\t\t\t(number >>> 6) & 0x3f,\r\n\t\t\t\t(number & 0x3f) + 0x40)\r\n\t\t} else if (number < 0x400000000000) { // 46 bits of number (needed for dates!)\r\n\t\t\tserializedToken = String.fromCharCode(\r\n\t\t\t\t(type << 4) + (number / 0x40000000000 >>> 0),\r\n\t\t\t\t(number / 0x1000000000) & 0x3f,\r\n\t\t\t\t(number / 0x40000000) & 0x3f,\r\n\t\t\t\t(number >>> 24) & 0x3f,\r\n\t\t\t\t(number >>> 18) & 0x3f,\r\n\t\t\t\t(number >>> 12) & 0x3f,\r\n\t\t\t\t(number >>> 6) & 0x3f,\r\n\t\t\t\t(number & 0x3f) + 0x40)\r\n\t\t} else {\r\n\t\t\tthrow new Error('Too big of number')\r\n\t\t}\r\n\t\tserialized += serializedToken\r\n\t}\r\n\tfunction writeString(string) {\r\n\t\tserialized += string\r\n\t}\r\n\tfunction getSerialized() {\r\n\t\treturn serialized\r\n\t}\r\n\treturn {\r\n\t\twriteToken: writeToken,\r\n\t\twriteString: writeString,\r\n\t\t//writeBuffer,\r\n\t\tgetSerialized: getSerialized,\r\n\t\t//insertBuffer,\r\n\t\t//flush,\r\n\t\tstartSequence: function() {\r\n\t\t\twriteToken(SEQUENCE_CODE, OPEN_SEQUENCE)\r\n\t\t},\r\n\t\tendSequence: function() {\r\n\t\t\twriteToken(SEQUENCE_CODE, END_SEQUENCE)\r\n\t\t},\r\n\t\tgetOffset: function() {// unsupported\r\n\t\t\treturn -1\r\n\t\t}\r\n\t}\r\n}\r\nvar ArrayFrom = Array.from || function(iterable, keyValue) {\r\n\tvar array = []\r\n\tvar keyValue = iterable.constructor === Map\r\n\titerable.forEach(function(key, value) {\r\n\t\tif (keyValue) {\r\n\t\t\tarray.push([value, key])\r\n\t\t} else {\r\n\t\t\tarray.push(key)\r\n\t\t}\r\n\t})\r\n\treturn array\r\n}\r\n\r\nfunction writeMap(map) {\r\n\tvar keyValues = ArrayFrom(map)\r\n\tfor (var i = 0, length = keyValues.length; i < length; i++) {\r\n\t\tvar keyValue = keyValues[i]\r\n\t\tkeyValues[i] = {\r\n\t\t\tkey: keyValue[0],\r\n\t\t\tvalue: keyValue[1]\r\n\t\t}\r\n\t}\r\n\treturn keyValues\r\n}\r\nfunction writeSet(set) {\r\n\treturn ArrayFrom(set)\r\n}\r\nfunction writeDate(date) {\r\n\treturn date.getTime()\r\n}", "\"use strict\"\r\nconst { Transform } = require('stream')\r\nconst { createSerializer } = require('./serialize')\r\n// a readable stream for serializing a set of variables to a JSON stream\r\nclass DPackSerializeStream extends Transform {\r\n\r\n\tconstructor(options) {\r\n\t\t// Calls the stream.Readable(options) constructor\r\n\t\toptions = options || {}\r\n\t\tsuper(options)\r\n\t\tthis.options = options\r\n\t\tthis.continueWriting = true\r\n\t}\r\n\twrite(value) {\r\n\t\tconst serializer = this.serializer || (this.serializer = createSerializer({ asBlock: true }))\r\n\t\tserializer.serialize(value)\r\n\t\tconst buffer = serializer.getSerialized()\r\n\t\tif (buffer.then) {\r\n\t\t\t// we need to wait for this to finish, spawn a new serializer to handle any other writes\r\n\t\t\tbuffer.then(buffer => this.push(buffer))\r\n\t\t\tthis.serializer = null\r\n\t\t} else {\r\n\t\t\tserializer.flush(this)\r\n\r\n\t\t}\r\n\t}\r\n\r\n\tend(value) {\r\n\t\tif (value) {\r\n\t\t\tthis.options.outlet = this\r\n\t\t\tconst serializer = this.serializer || (this.serializer = createSerializer(this.options))\r\n\t\t\tserializer.serialize(value) // we do not need to write the last value as a block, its state won't affect anything afterwards\r\n\t\t}\r\n\t\tif (this.serializer.pendingEncodings.length > 0) {\r\n\t\t\tthis.endWhenDone = true\r\n\t\t\tthis.writeNext()\r\n\t\t} else {\r\n\t\t\tthis.serializer.flush()\r\n\t\t\tthis.push(null)\r\n\t\t}\r\n\t}\r\n\r\n\twriteBytes(buffer) {\r\n\t\ttry {\r\n\t\t\tthis.continueWriting = this.push(buffer)\r\n\t\t} catch(error) {\r\n\t\t\tthrow error\r\n\t\t}\r\n\t}\r\n\r\n\t_read() {\r\n\t\tthis.continueWriting = true\r\n\t\tif(!this.pausedForPromise && this.serializer && this.endWhenDone && this.serializer.pendingEncodings.length > 0) {\r\n\t\t\tthis.writeNext()\r\n\t\t}\r\n\t}\r\n\twriteNext() {\r\n\t\tvar isSync\r\n\t\tdo {\r\n\t\t\tvar hasMoreToSend = this.serializer.pendingEncodings.length > 0\r\n\t\t\tisSync = null\r\n\t\t\tif (hasMoreToSend) {\r\n\t\t\t\tthis.serializer.pendingEncodings.shift().then(() => {\r\n\t\t\t\t\tif (isSync === false) {\r\n\t\t\t\t\t\t// if we are async, call writeNext which will look for more pending encodings\r\n\t\t\t\t\t\tthis.pausedForPromise = false\r\n\t\t\t\t\t\tif (this.continueWriting || this.serializer.pendingEncodings.length === 0)\r\n\t\t\t\t\t\t\tthis.writeNext()\r\n\t\t\t\t\t\telse { // backpressure, flush and wait for flow\r\n\t\t\t\t\t\t\tthis.serializer.flush() // flush what we have before waiting for _read call\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// mark it as sync so we can exit and loop instead of recursing\r\n\t\t\t\t\t\tisSync = true\r\n\t\t\t\t\t}\r\n\t\t\t\t}, (error) => {\r\n\t\t\t\t\t// the serializer should handle promise errors, but if that fails, end the stream with the error\r\n\t\t\t\t\tconsole.error(error)\r\n\t\t\t\t\tthis.push(error.toString())\r\n\t\t\t\t\tthis.push(null)\r\n\t\t\t\t})\r\n\t\t\t\tif (!isSync) { // async promise, flush what we have and wait for promise\r\n\t\t\t\t\tisSync = false\r\n\t\t\t\t\t// flush what we have so far while waiting for the promise\r\n\t\t\t\t\tthis.pausedForPromise = true\r\n\t\t\t\t\tthis.serializer.flush()\r\n\t\t\t\t} else if (!this.continueWriting && this.serializer.pendingEncodings.length > 0) {\r\n\t\t\t\t\tthis.serializer.flush() // flush what we have\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t} else if (this.endWhenDone) {\r\n\t\t\t\tthis.serializer.flush()\r\n\t\t\t\tthis.push(']')\r\n\t\t\t\tthis.push(null)\r\n\t\t\t}\r\n\t\t} while (isSync)\r\n\t}\r\n}\r\n\r\nexports.createSerializeStream = () => {\r\n\treturn new DPackSerializeStream()\r\n}\r\n", "\"use strict\"\r\n\r\n// type codes:\r\n// these are the codes that are used to determine the rudimentary type of numbers\r\nvar PROPERTY_CODE = 0\r\nvar TYPE_CODE = 3\r\nvar STRING_CODE = 2\r\nvar NUMBER_CODE = 1\r\nvar SEQUENCE_CODE = 7\r\n\r\n// constant codes\r\nvar NULL = 0 // p\r\nvar FALSE = 3 // s\r\nvar TRUE = 4 // t\r\nvar UNDEFINED = 5 // u\r\n\r\n// these are the starting codes (structures also use this space) for complete types\r\nvar DEFAULT_TYPE = 6\r\nvar ARRAY_TYPE = 7\r\nvar REFERENCING_TYPE = 8\r\nvar NUMBER_TYPE = 9\r\nvar EXTENSIONS = 10\r\nvar METADATA_TYPE = 11\r\nvar COPY_PROPERTY = 12  // for defining a typed object without returning the value\r\nvar REFERENCING_POSITION = 13\r\nvar TYPE_DEFINITION = 14  // for defining a typed object without returning the value\r\n\r\nvar ERROR_METADATA = 500\r\n// sequence codes\r\nvar OPEN_SEQUENCE = 12 // <\r\nvar PARTIAL_DEFERRED_REFERENCE = 12 // <\r\nvar END_SEQUENCE = 14 // >\r\nvar DEFERRED_REFERENCE = 15 // ?\r\n\r\nvar MAX_LENGTH = 1024*1024*16\r\nvar PAUSED = {}\r\n\r\nfunction createParser(options) {\r\n\tif (!options)\r\n\t\toptions = {}\r\n\tvar offset\r\n\tvar source\r\n\tvar isPartial\r\n\tvar classByName = options.classByName || new Map()\r\n\tclassByName.set('Map', readMap)\r\n\tclassByName.set('Set', readSet)\r\n\tclassByName.set('Date', readDate)\r\n\tvar pausedState\r\n\tvar deferredReads\r\n\r\n\tfunction pause(state, lastRead) {\r\n\t\tstate.previous = pausedState\r\n\t\tstate.resume = true\r\n\t\tpausedState = state\r\n\t\tif (!isPartial)\r\n\t\t\tthrow new Error('Unexpected end of dpack stream')\r\n\r\n\t\tif (!parser.onResume) // only if not already defined, otherwise we just want to use the one from the top of the call stack\r\n\t\t\tparser.onResume = function(nextString, isPartialString, rebuildString) {\r\n\t\t\t\t// top of the resume stack\r\n\t\t\t\tvar resumeState = pausedState\r\n\t\t\t\tpausedState = null\r\n\t\t\t\tparser.onResume = null\r\n\t\t\t\t// we slice and add these together to generate an entirely new string\r\n\t\t\t\t// so we don't cause a memory leak with redundant strings that a retained a slice parents\r\n\t\t\t\tif (lastRead < source.length)\r\n\t\t\t\t\tsource = source.slice(lastRead) + nextString\r\n\t\t\t\telse {\r\n\t\t\t\t\tif (rebuildString) // if we have read all of source, we want to slice and re-concatenate to eliminate the slice reference to the parent, we really don't want that retained in memory\r\n\t\t\t\t\t\tsource = nextString.slice(0, 1) + nextString.slice(1)\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tsource = nextString\r\n\t\t\t\t}\r\n\t\t\t\tisPartial = isPartialString\r\n\t\t\t\tdisposedChars += lastRead\r\n\t\t\t\toffset = 0\r\n\t\t\t\treturn resumeState.reader ? resumeState.reader(resumeState) : readSequence(resumeState.length, resumeState)\r\n\t\t\t}\r\n\t\treturn state.object\r\n\t}\r\n\r\n\tfunction readSequence(length, thisProperty) {\r\n\t\t/* propertyStates:\r\n\t\t0 - starting next property slot\r\n\t\t1 - property created, succeeding value should be value of property\r\n\t\t2 - property creation in progress, next value should define key\r\n\t\t11+ - modifying property, next value modifies property (adds metadata, position, type, etc.)\r\n\t\t*/\r\n\t\tvar propertyState = 0\r\n\t\tthisProperty = thisProperty || []\r\n\t\tvar property, isArray, object, value, i = 0, propertyIndex = 0\r\n\t\tif (thisProperty.resume) { // resuming, thisProperty is the resume state.\r\n\t\t\tproperty = thisProperty.previous\r\n\t\t\tif (property) {\r\n\t\t\t\t// do the previous/upper stack frame first\r\n\t\t\t\tvar value = property.reader ? property.reader(property) : readSequence(property.length, property)\r\n\t\t\t\tvar values = property.values\r\n\t\t\t\tif (values) {\r\n\t\t\t\t\t// we have an assignment to referencing values that is waiting for pausing to complete\r\n\t\t\t\t\tif (pausedState) {\r\n\t\t\t\t\t\t// if still paused, pass on to next pausedState\r\n\t\t\t\t\t\tpausedState.values = values\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (value.nextPosition > -1) {\r\n\t\t\t\t\t\t\t// we use this path for fulfilling forward references, and when the position is reset\r\n\t\t\t\t\t\t\tvalues[values.nextPosition++] = value\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tvalues.push(value)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (thisProperty.code && thisProperty.code !== thisProperty.thisProperty.code) {\r\n\t\t\t\tthisProperty.resume = false // if the resume property has been reassigned to an incompatible type, can't switch\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\ti = thisProperty.i || 0\r\n\t\t\t\tobject = thisProperty.object\r\n\t\t\t\tpropertyState = thisProperty.propertyState || 0\r\n\t\t\t\tpropertyIndex = thisProperty.propertyIndex || 0\r\n\t\t\t\tthisProperty = thisProperty.thisProperty\r\n\t\t\t}\r\n\t\t}\r\n\t\tisArray = thisProperty.code === ARRAY_TYPE/*ARRAY_TYPE*/\r\n\t\tobject = object || (thisProperty.constructs ? new thisProperty.constructs() : isArray ? [] : {}) // TODO: we could probably construct a new reader that does this a little faster\r\n\t\tfor (; i < length;) {\r\n\t\t\tvar type, number\r\n\t\t\tvar lastRead = offset\r\n\t\t\tvar token = source.charCodeAt(offset++)\r\n\t\t\tif (token >= 0x30) { // fast path for one byte with stop bit\r\n\t\t\t\tif (token > 0x3000) { // long-token handling\r\n\t\t\t\t\ttype = (token >>> 12) ^ 4\r\n\t\t\t\t\tnumber = token & 0xfff\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttype = (token >>> 4) ^ 4\r\n\t\t\t\t\tnumber = token & 0xf\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\ttype = (token >>> 4) & 11 // shift and omit the stop bit (bit 3)\r\n\t\t\t\tnumber = token & 0xf\r\n\t\t\t\ttoken = source.charCodeAt(offset++)\r\n\t\t\t\tnumber = (number << 6) + (token & 0x3f) // 10 bit number\r\n\t\t\t\tif (!(token >= 0x40)) {\r\n\t\t\t\t\ttoken = source.charCodeAt(offset++)\r\n\t\t\t\t\tnumber = (number << 6) + (token & 0x3f) // 16 bit number\r\n\t\t\t\t\tif (!(token >= 0x40)) {\r\n\t\t\t\t\t\ttoken = source.charCodeAt(offset++)\r\n\t\t\t\t\t\tnumber = (number << 6) + (token & 0x3f) // 22 bit number\r\n\t\t\t\t\t\tif (!(token >= 0x40)) {\r\n\t\t\t\t\t\t\ttoken = source.charCodeAt(offset++)\r\n\t\t\t\t\t\t\tnumber = (number << 6) + (token & 0x3f) // 28 bit number\r\n\t\t\t\t\t\t\tif (!(token >= 0x40)) {\r\n\t\t\t\t\t\t\t\ttoken = source.charCodeAt(offset++)\r\n\t\t\t\t\t\t\t\tnumber = (number * 0x40) + (token & 0x3f) // 34 bit number (we can't use 32-bit shifting operators anymore)\r\n\t\t\t\t\t\t\t\tif (!(token >= 0x40)) {\r\n\t\t\t\t\t\t\t\t\ttoken = source.charCodeAt(offset++)\r\n\t\t\t\t\t\t\t\t\tnumber = (number * 0x40) + (token & 0x3f) // 40 bit number\r\n\t\t\t\t\t\t\t\t\tif (!(token >= 0x40)) {\r\n\t\t\t\t\t\t\t\t\t\ttoken = source.charCodeAt(offset++)\r\n\t\t\t\t\t\t\t\t\t\tnumber = (number * 0x40) + (token & 0x3f) // 46 bit number, we don't go beyond this\r\n\t\t\t\t\t\t\t\t\t\tif (!(token >= 0)) {\r\n\t\t\t\t\t\t\t\t\t\t\tif (offset > source.length) {\r\n\t\t\t\t\t\t\t\t\t\t\t\treturn pause({\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tlength: length,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tthisProperty: thisProperty,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\ti: i,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tobject: object,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tpropertyIndex: propertyIndex,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tpropertyState: propertyState,\r\n\t\t\t\t\t\t\t\t\t\t\t\t}, lastRead)\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (type === 0) { /*PROPERTY_CODE*/\r\n\t\t\t\tpropertyIndex = number\r\n\t\t\t\tpropertyState = 0\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\tproperty = thisProperty[propertyIndex]\r\n\t\t\tif (type === 3) { /*TYPE_CODE*/\r\n\t\t\t\t// we store the previous property state in token, so we can assign the next one\r\n\t\t\t\tif (number < 6) {\r\n\t\t\t\t\t// special values (constants, deferreds)\r\n\t\t\t\t\tif (number < 3) {\r\n\t\t\t\t\t\tif (number === 0) {\r\n\t\t\t\t\t\t\tvalue = null\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tvalue = 'Unknown token, type: ' + type + ' number: ' + number\r\n\t\t\t\t\t\t} \r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (number === TRUE) {\r\n\t\t\t\t\t\t\tvalue = true\r\n\t\t\t\t\t\t} else if (number === FALSE) {\r\n\t\t\t\t\t\t\tvalue = false\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tvalue = undefined\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (number <= NUMBER_TYPE) {\r\n\t\t\t\t\t\t// property definition\r\n\t\t\t\t\t\tif (propertyState === 1) {\r\n\t\t\t\t\t\t\t// we were in property value position, but no value, so we increment position here\r\n\t\t\t\t\t\t\tpropertyIndex++\r\n\t\t\t\t\t\t\ti++\r\n\t\t\t\t\t\t\tproperty = thisProperty[propertyIndex]\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (propertyIndex < thisProperty.resetTo) {\r\n\t\t\t\t\t\t\tthrow new Error('Overwriting frozen property')\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (property) {\r\n\t\t\t\t\t\t\tif (!property.resume) {\r\n\t\t\t\t\t\t\t\tvalue = property.key // inherit the existing key\r\n\t\t\t\t\t\t\t\tproperty = thisProperty[propertyIndex] = []\r\n\t\t\t\t\t\t\t\tproperty.key = value\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else { // no property existed in slot, start with default key of null\r\n\t\t\t\t\t\t\tproperty = thisProperty[propertyIndex] = []\r\n\t\t\t\t\t\t\tproperty.key = null\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tproperty.code = number\r\n\t\t\t\t\t\tproperty.parent = thisProperty\r\n\t\t\t\t\t\t//property.key = null\r\n\t\t\t\t\t\tpropertyState = 2 // read next value as the key\r\n\t\t\t\t\t\tif (number === REFERENCING_TYPE/*REFERENCING_TYPE*/) {\r\n\t\t\t\t\t\t\tproperty.values = []\r\n\t\t\t\t\t\t} else if (number === ARRAY_TYPE) {\r\n\t\t\t\t\t\t\tproperty[0] = []\r\n\t\t\t\t\t\t\tproperty[0].key = null\r\n\t\t\t\t\t\t\tproperty[0].code = DEFAULT_TYPE\r\n\t\t\t\t\t\t\tproperty[0].parent = property\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// property modification\r\n\t\t\t\t\t\tpropertyState = number\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcontinue\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif (type === 2 /*STRING_CODE*/) {\r\n\t\t\t\t\tvalue = source.slice(offset, offset += number)\r\n\t\t\t\t\tif (offset > source.length) {\r\n\t\t\t\t\t\treturn pause({\r\n\t\t\t\t\t\t\tlength: length,\r\n\t\t\t\t\t\t\tthisProperty: thisProperty,\r\n\t\t\t\t\t\t\ti: i,\r\n\t\t\t\t\t\t\tobject: object,\r\n\t\t\t\t\t\t\tpropertyIndex: propertyIndex,\r\n\t\t\t\t\t\t\tpropertyState: propertyState\r\n\t\t\t\t\t\t}, lastRead)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (propertyState < 2) {\r\n\t\t\t\t\t\tif (property.code === NUMBER_TYPE/*NUMBER_TYPE*/) {\r\n\t\t\t\t\t\t\tvalue = +value\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (type === 1) { /*NUMBER_CODE*/\r\n\t\t\t\t\tvalue = number\r\n\t\t\t\t} else { /*if type == 7 SEQUENCE_CODE*/\r\n\t\t\t\t\tif (number > 13) {\r\n\t\t\t\t\t\tif (number === END_SEQUENCE)\r\n\t\t\t\t\t\t\treturn object\r\n\t\t\t\t\t\telse if (number === DEFERRED_REFERENCE) {\r\n\t\t\t\t\t\t\tvalue = readSequence(0, property)\r\n\t\t\t\t\t\t\tpropertyState = 0\r\n\t\t\t\t\t\t\tif (options.forDeferred) {\r\n\t\t\t\t\t\t\t\tvalue = options.forDeferred(value, property)\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t(deferredReads || (deferredReads = [])).push({\r\n\t\t\t\t\t\t\t\t\tproperty: property,\r\n\t\t\t\t\t\t\t\t\tvalue: value\r\n\t\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (number >= OPEN_SEQUENCE) {\r\n\t\t\t\t\t\t\tnumber = 2000000000\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (propertyState > 1) {\r\n\t\t\t\t\t\t\tif (propertyState === 2) {\r\n\t\t\t\t\t\t\t\tpropertyState = 0 // if the property key was skipped, go directly into value mode\r\n\t\t\t\t\t\t\t\tvalue = readSequence(number, property)\r\n\t\t\t\t\t\t\t} else if (propertyState === METADATA_TYPE)\r\n\t\t\t\t\t\t\t\tvalue = readSequence(number, [{ key: null, code: 6 }])\r\n\t\t\t\t\t\t\telse if (property.resume && (property.code || DEFAULT_TYPE) === property.thisProperty.code)\r\n\t\t\t\t\t\t\t\tvalue = readSequence(number, property.thisProperty)\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\tvalue = readSequence(number, property)\r\n\t\t\t\t\t\t} else\r\n\t\t\t\t\t\t\tvalue = readSequence(number, property)\r\n\t\t\t\t\t\tif (pausedState) {\r\n\t\t\t\t\t\t\tif (value === undefined) { // or a PAUSED object\r\n\t\t\t\t\t\t\t\tpausedState = null // erase anything further up in the stack, as this means the sequence couldn't start, so we need to re-parse from here\r\n\t\t\t\t\t\t\t\tparser.onResume = null\r\n\t\t\t\t\t\t\t\treturn pause({\r\n\t\t\t\t\t\t\t\t\tlength: length,\r\n\t\t\t\t\t\t\t\t\tthisProperty: thisProperty,\r\n\t\t\t\t\t\t\t\t\ti: i,\r\n\t\t\t\t\t\t\t\t\tobject: object,\r\n\t\t\t\t\t\t\t\t\tproperty: property,\r\n\t\t\t\t\t\t\t\t\tpropertyIndex: propertyIndex,\r\n\t\t\t\t\t\t\t\t\tpreviousProperty: previousProperty,\r\n\t\t\t\t\t\t\t\t\tpropertyState: propertyState,\r\n\t\t\t\t\t\t\t\t}, lastRead)\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t// need to assign the values *after* the completion of the sequence if it is a forward reference\r\n\t\t\t\t\t\t\t\tpausedState.values = property.values instanceof Array ? property.values : undefined\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}/*else if (values) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}*/\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!property) {\r\n\t\t\t\tthrow new Error('No property defined for slot' + (thisProperty.key ? ' in ' + thisProperty.key : ''))\r\n\t\t\t}\r\n\t\t\tif (propertyState < 2 && property && property.code === REFERENCING_TYPE/*REFERENCING_TYPE*/) {\r\n\t\t\t\tvar values = property.values\r\n\t\t\t\tif (typeof value === 'number') {\r\n\t\t\t\t\tvalue = values[number]\r\n\t\t\t\t\tif (value === undefined && !((number) in values)) {\r\n\t\t\t\t\t\tthrow new Error('Referencing value that has not been read yet')\r\n\t\t\t\t\t}\t\t\t\t\t\r\n\t\t\t\t} else if ((type === 2 || type === 7) && values) { // only strings and sequences\r\n\t\t\t\t\tif (values.nextPosition > -1) {\r\n\t\t\t\t\t\t// we use this path for fulfilling forward references\r\n\t\t\t\t\t\tif (property.recordValueReference) {\r\n\t\t\t\t\t\t\tproperty.recordValueReference(values)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvalues[values.nextPosition++] = value\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tvalues.push(value)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (propertyState > 1) {\r\n\t\t\t\t// 0, 1: values are the value of the property\r\n\t\t\t\tif (propertyState === 2) { // property key\r\n\t\t\t\t\tproperty.key = value\r\n\t\t\t\t} else if (propertyState === METADATA_TYPE) { // 3: metadata paramater\r\n\t\t\t\t\tif (typeof value === 'string') {\r\n\t\t\t\t\t\tvar extendedType = classByName.get(value)\r\n\t\t\t\t\t\tif (extendedType) {\r\n\t\t\t\t\t\t\tif (extendedType.fromValue) {\r\n\t\t\t\t\t\t\t\tproperty.fromValue = extendedType.fromValue\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tproperty.constructs = extendedType\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else if (options.errorOnUnknownClass) {\r\n\t\t\t\t\t\t\tthrow new Error('Attempt to deserialize to unknown class ' + parameter)\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// if no warning, just parse as a plain value/object\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tproperty.extendedType = extendedType // if this gets used for serialization, this is needed\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// extended metadata assignment (used by shared structures to mark objects as unstructured)\r\n\t\t\t\t\t\tproperty.metadata = value\r\n\t\t\t\t\t\tif (value === ERROR_METADATA)\r\n\t\t\t\t\t\t\tproperty.fromValue = onError\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (propertyState === REFERENCING_POSITION) {\r\n\t\t\t\t\tvar values = property.values || (property.values = [])\r\n\t\t\t\t\t//values.splice(value, values.length)\r\n\t\t\t\t\tvalues.nextPosition = value\r\n\t\t\t\t} else if (propertyState === TYPE_DEFINITION) { // for type-only state\r\n\t\t\t\t\t// throw away this value and read next value as the real value\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow new Error('Unknown property type ' + propertyState)\r\n\t\t\t\t}\r\n\t\t\t\tpropertyState = 1 // property value after definition position\r\n\t\t\t\tcontinue // read next value as the property value\r\n\t\t\t} else {\r\n\t\t\t\tpropertyState = 0\r\n\t\t\t}\r\n\t\t\tif (property.fromValue) {\r\n\t\t\t\tvalue = property.fromValue(value)\r\n\t\t\t}\r\n\t\t\tif (isArray && property.key === null) {\r\n\t\t\t\tobject.push(value)\r\n\t\t\t} else if (value !== undefined) {\r\n\t\t\t\tobject[property.key] = value\r\n\t\t\t}\r\n\t\t\ti++\r\n\t\t\tif (!isArray)\r\n\t\t\t\tpropertyIndex++\r\n\t\t}\r\n\t\treturn object\r\n\t}\r\n\r\n\tfunction unknownType(number) {\r\n\t\tthrow new Error('Unknown type ' + number)\r\n\t}\r\n\tvar nonParsingError\r\n\tfunction onError(error) {\r\n\t\tvar g = typeof global != 'undefined' ? global : window\r\n\t\tif (error && error.name && g[error.name])\r\n\t\t\terror = new g[error.name](error.message)\r\n\t\telse if (typeof error == 'string')\r\n\t\t\terror = new Error(error)\r\n\t\tif (options.onError)\r\n\t\t\toptions.onError(error)\r\n\t\telse {\r\n\t\t\tnonParsingError = true\r\n\t\t\tthrow error\r\n\t\t}\r\n\t}\r\n\r\n\tvar disposedChars = 0\r\n\tfunction read(property) {\r\n\t\ttry {\r\n\t\t\tif (property && property.resume) {\r\n\t\t\t\tvar previous = property.previous\r\n\t\t\t\tvalue = readSequence(previous.length, previous)\r\n\t\t\t\t// once we get the value, we don't know which point in the stack could still be resolving\r\n\t\t\t\tvalue = property.object || value\r\n\t\t\t\tproperty = property.property\r\n\t\t\t} else {\r\n\t\t\t\tproperty = property || [options && options.shared || {\r\n\t\t\t\t\tkey: null,\r\n\t\t\t\t\tcode: 6\r\n\t\t\t\t}]\r\n\t\t\t\tvar value = readSequence(1, property)[property[0].key]\r\n\t\t\t}\r\n\t\t\twhile (true) {\r\n\t\t\t\tif (pausedState) {\r\n\t\t\t\t\treturn pause({\r\n\t\t\t\t\t\treader: read,\r\n\t\t\t\t\t\tobject: value,\r\n\t\t\t\t\t\tproperty: property\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t\tif (!deferredReads) {\r\n\t\t\t\t\treturn value\r\n\t\t\t\t}\r\n\t\t\t\tvar index = deferredReads.index || 0\r\n\t\t\t\tvar deferredRead = deferredReads[index]\r\n\t\t\t\tdeferredReads.index = index + 1\r\n\t\t\t\tif (!deferredRead) {\r\n\t\t\t\t\tdeferredReads = deferredReads.parent\r\n\t\t\t\t\tcontinue\r\n\t\t\t\t}\r\n\t\t\t\tvar target = deferredRead.value\r\n\t\t\t\tvar parentDeferredReads = deferredReads\r\n\t\t\t\tdeferredReads = []\r\n\t\t\t\tdeferredReads.parent = parentDeferredReads\r\n\t\t\t\tvar targetProperty = deferredRead.property\r\n\t\t\t\tvar result = readSequence(1, property = [{\r\n\t\t\t\t\tresume: true,\r\n\t\t\t\t\tkey: null,\r\n\t\t\t\t\tthisProperty: targetProperty,\r\n\t\t\t\t\tobject: target\r\n\t\t\t\t}])\r\n\t\t\t\tresult = result.null || result[targetProperty.key] // Blocks should use null as the root key, but could have the target property key as well\r\n\t\t\t\tif (result != target) { // This should only occur with a promise that resolves to a different type, an array\r\n\t\t\t\t\t// object was replaced with something else (an array, presumably)\r\n\t\t\t\t\tObject.assign(target, result)\r\n\t\t\t\t\tif (pausedState && pausedState.object === result) {\r\n\t\t\t\t\t\tpausedState.object = target\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (result && result.constructor === Array) {\r\n\t\t\t\t\t\ttarget.length = result.length\r\n\t\t\t\t\t\tObject.setPrototypeOf(target, Object.getPrototypeOf(result)) // do our best to make it array like\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} catch(error) {\r\n\t\t\tif (!nonParsingError)\r\n\t\t\t\terror.message = 'DPack parsing error: ' + error.message + ' at position: ' + (offset + disposedChars) + ' near: ' + source.slice(offset - 10, offset + 10)\r\n\t\t\tthrow error\r\n\t\t}\r\n\t}\r\n\r\n\tvar parser = {\r\n\t\tsetSource: function(string, startOffset, isPartialString) {\r\n\t\t\tsource = string\r\n\t\t\toffset = startOffset || 0\r\n\t\t\tdisposedChars = 0\r\n\t\t\tisPartial = isPartialString\r\n\t\t\treturn this\r\n\t\t},\r\n\t\thasMoreData: function() {\r\n\t\t\treturn source.length > offset\r\n\t\t},\r\n\t\tisPaused: function() {\r\n\t\t\treturn pausedState\r\n\t\t},\r\n\t\thasUnfulfilledReferences: function() {\r\n\t\t\treturn deferredReads && deferredReads.length > deferredReads.index\r\n\t\t},\r\n\t\tgetOffset: function() {\r\n\t\t\treturn offset + disposedChars\r\n\t\t},\r\n\t\tread: read\r\n\t}\r\n\treturn parser\r\n}\r\nexports.parse = function(stringOrBuffer, options) {\r\n\tvar source\r\n\tif (typeof stringOrBuffer === 'string') {\r\n\t\tsource = stringOrBuffer\r\n\t} else if (stringOrBuffer && stringOrBuffer.toString) {\r\n\t\tsource = stringOrBuffer.toString(options && options.encoding || 'utf8')\r\n\t} else { // whatever (undefined or null or whatever), just return it\r\n\t\treturn stringOrBuffer\r\n\t}\r\n\tvar parser = createParser(options).setSource(source)\r\n\tif (options && options.shared)\r\n\t\treturn parser.read([options.shared])\r\n\treturn parser.read()\r\n}\r\nexports.createParser = createParser\r\n\r\nvar readMap = {\r\n\tfromValue: function(entries) {\r\n\t\tvar map = new Map()\r\n\t\tfor (var i = 0, l = entries.length; i < l; i++) {\r\n\t\t\tvar entry = entries[i]\r\n\t\t\tmap.set(entry.key, entry.value)\r\n\t\t}\r\n\t\treturn map\r\n\t}\r\n}\r\nvar readSet = {\r\n\tfromValue: function(values) {\r\n\t\tvar set = new Set(values)\r\n\t\tif (set.size === 0 && values.length > 0) {\r\n\t\t\tfor (var i = 0, l = values.length; i < l; i++) {\r\n\t\t\t\tset.add(values[i])\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn set\r\n\t}\r\n}\r\nvar readDate = {\r\n\tfromValue: function(time) {\r\n\t\treturn new Date(time)\r\n\t}\r\n}\r\n\r\n", "\"use strict\"\r\nvar Transform = require('stream').Transform\r\nvar createParser = require('./parse').createParser\r\nvar DEFAULT_OPTIONS = {objectMode: true}\r\n\r\nclass DPackParseStream extends Transform {\r\n\tconstructor(options) {\r\n\t\tif (options) {\r\n\t\t\toptions.objectMode = true\r\n\t\t} else {\r\n\t\t\toptions = DEFAULT_OPTIONS\r\n\t\t}\r\n\t\tsuper(options)\r\n\t\tthis.parser = createParser(options)\r\n\t\tthis.waitingValues = []\r\n\t}\r\n\t_transform(chunk, encoding, callback) {\r\n\t\tvar value\r\n\t\ttry {\r\n\t\t\tvar sourceString = chunk.toString()\r\n\t\t\tvar parser = this.parser\r\n\t\t\tif (parser.onResume) {\r\n\t\t\t\tvalue = parser.onResume(sourceString, true)\r\n\t\t\t\tif (!parser.isPaused())\r\n\t\t\t\t\tthis.sendValue(value)\r\n\t\t\t} else {\r\n\t\t\t\tparser.setSource(sourceString, 0, true)\r\n\t\t\t}\r\n\t\t\twhile (parser.hasMoreData()) {\r\n\t\t\t\tvalue = parser.read()\r\n\t\t\t\tif (parser.isPaused())\r\n\t\t\t\t\tbreak\r\n\t\t\t\telse\r\n\t\t\t\t\tthis.sendValue(value)\r\n\t\t\t}\r\n\t\t} catch (error) { // must catch errors here, and still call callback\r\n\t\t\tconsole.error(error)\r\n\t\t}\r\n\t\tif (callback) callback()\r\n\t}\r\n\tsendValue(value) {\r\n\t\tif (this.parser.hasUnfulfilledReferences()) {\r\n\t\t\tif (value !== undefined) {\r\n\t\t\t\tthis.waitingValues.push(value)\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\twhile (this.waitingValues.length > 0) {\r\n\t\t\t\tthis.push(this.waitingValues.shift())\r\n\t\t\t}\r\n\t\t\tif (value !== undefined) {\r\n\t\t\t\tthis.push(value)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexports.createParseStream = () => new DPackParseStream()\r\n", "var PREFERRED_MAX_BUFFER_SIZE = 0x8000\r\nvar availableBuffers = []\r\nfunction nodeCharEncoder(options) {\r\n\tvar offset = options.startOffset || 0\r\n\tvar bufferSize\r\n\tvar outlet = options.outlet\r\n\tvar buffer = availableBuffers.pop()\r\n\tif (buffer && buffer.length > offset + 0x80) {\r\n\t\t// reuse existing buffer if we can\r\n\t\tbufferSize = buffer.length\r\n\t} else {\r\n\t\tbufferSize = (offset >> 12 << 12) + 0x2000\r\n\t\tbuffer = Buffer.allocUnsafeSlow(bufferSize)\r\n\t}\r\n\tvar encoding = options.encoding\r\n\tvar sequences = []\r\n\tfunction makeRoom(bytesNeeded) {\r\n\t\tif (outlet) {\r\n\t\t\toutlet.writeBytes(buffer.slice(0, offset))\r\n\t\t\tif (bufferSize < PREFERRED_MAX_BUFFER_SIZE || bytesNeeded > PREFERRED_MAX_BUFFER_SIZE) {\r\n\t\t\t\tbufferSize = Math.max(bufferSize * 4, bytesNeeded)\r\n\t\t\t}\r\n\t\t\tbuffer = Buffer.allocUnsafeSlow(bufferSize)\r\n\t\t\toffset = 0\r\n\t\t\tsequences = [] // clear insertion points\r\n\t\t\tencoder.hasWritten = true\r\n\t\t} else {\r\n\t\t\tbufferSize = Math.max(bufferSize * 4, bufferSize + bytesNeeded, 0x2000)\r\n\t\t\tvar oldBuffer = buffer\r\n\t\t\tbuffer = Buffer.allocUnsafeSlow(bufferSize)\r\n\t\t\toldBuffer.copy(buffer, 0, 0, offset)\r\n\t\t}\r\n\t}\r\n\tfunction flush(specifiedOutlet) {\r\n\t\t(specifiedOutlet || outlet).writeBytes(buffer.slice(0, offset))\r\n\t\tif (offset + 0x80 > buffer.length)\r\n\t\t\tbuffer = Buffer.allocUnsafeSlow(bufferSize = Math.min(Math.max((offset >> 10 << 10) + 0x2000, bufferSize), 0x8000)) // allocate a new buffer, don't want to overwrite the bytes in the old one while they are in use!\r\n\t\telse {// or continue to use the remaining space in this buffer, if there is a lot of room left\r\n\t\t\tbuffer = buffer.slice(offset)\r\n\t\t\tbufferSize = buffer.length\r\n\t\t}\r\n\t\toffset = 0\r\n\t\tsequences = [] // clear insertion points\r\n\t}\r\n\tfunction writeToken(type, number) {\r\n\t\tif (number < 0x10) { // 4 bits of number\r\n\t\t\tbuffer[offset++] = ((type << 4) + number) ^ 0x40\r\n\t\t} else if (number < 0x400) { // 10 bits of number\r\n\t\t\tbuffer[offset++] = (type << 4) + (number >>> 6)\r\n\t\t\tbuffer[offset++] = (number & 0x3f) + 0x40\r\n\t\t} else if (number < 0x10000) { // 16 bits of number\r\n\t\t\tbuffer[offset++] = (type << 4) + (number >>> 12)\r\n\t\t\tbuffer[offset++] = (number >>> 6) & 0x3f\r\n\t\t\tbuffer[offset++] = (number & 0x3f) + 0x40\r\n\t\t} else if (number < 0x400000) { // 22 bits of number\r\n\t\t\tbuffer[offset++] = (type << 4) + (number >>> 18)\r\n\t\t\tbuffer[offset++] = (number >>> 12) & 0x3f\r\n\t\t\tbuffer[offset++] = (number >>> 6) & 0x3f\r\n\t\t\tbuffer[offset++] = (number & 0x3f) + 0x40\r\n\t\t} else if (number < 0x10000000) { // 28 bits of number\r\n\t\t\tbuffer[offset++] = (type << 4) + (number >>> 24)\r\n\t\t\tbuffer[offset++] = (number >>> 18) & 0x3f\r\n\t\t\tbuffer[offset++] = (number >>> 12) & 0x3f\r\n\t\t\tbuffer[offset++] = (number >>> 6) & 0x3f\r\n\t\t\tbuffer[offset++] = (number & 0x3f) + 0x40\r\n\t\t} else if (number < 0x100000000) { // 32 bits of number\r\n\t\t\tbuffer[offset++] = (type << 4) + (number >>> 30)\r\n\t\t\tbuffer[offset++] = (number >>> 24) & 0x3f\r\n\t\t\tbuffer[offset++] = (number >>> 18) & 0x3f\r\n\t\t\tbuffer[offset++] = (number >>> 12) & 0x3f\r\n\t\t\tbuffer[offset++] = (number >>> 6) & 0x3f\r\n\t\t\tbuffer[offset++] = (number & 0x3f) + 0x40\r\n\t\t} else if (number < 0x400000000) { // 34 bits of number\r\n\t\t\tbuffer[offset++] = (type << 4) + (number / 0x40000000 >>> 0)\r\n\t\t\tbuffer[offset++] = (number >>> 24) & 0x3f\r\n\t\t\tbuffer[offset++] = (number >>> 18) & 0x3f\r\n\t\t\tbuffer[offset++] = (number >>> 12) & 0x3f\r\n\t\t\tbuffer[offset++] = (number >>> 6) & 0x3f\r\n\t\t\tbuffer[offset++] = (number & 0x3f) + 0x40\r\n\t\t} else if (number < 0x10000000000) { // 40 bits of number\r\n\t\t\tbuffer[offset++] = (type << 4) + (number / 0x1000000000 >>> 0)\r\n\t\t\tbuffer[offset++] = (number / 0x40000000) & 0x3f\r\n\t\t\tbuffer[offset++] = (number >>> 24) & 0x3f\r\n\t\t\tbuffer[offset++] = (number >>> 18) & 0x3f\r\n\t\t\tbuffer[offset++] = (number >>> 12) & 0x3f\r\n\t\t\tbuffer[offset++] = (number >>> 6) & 0x3f\r\n\t\t\tbuffer[offset++] = (number & 0x3f) + 0x40\r\n\t\t} else if (number < 0x400000000000) { // 46 bits of number (needed for dates!)\r\n\t\t\tbuffer[offset++] = (type << 4) + (number / 0x40000000000 >>> 0)\r\n\t\t\tbuffer[offset++] = (number / 0x1000000000) & 0x3f\r\n\t\t\tbuffer[offset++] = (number / 0x40000000) & 0x3f\r\n\t\t\tbuffer[offset++] = (number >>> 24) & 0x3f\r\n\t\t\tbuffer[offset++] = (number >>> 18) & 0x3f\r\n\t\t\tbuffer[offset++] = (number >>> 12) & 0x3f\r\n\t\t\tbuffer[offset++] = (number >>> 6) & 0x3f\r\n\t\t\tbuffer[offset++] = (number & 0x3f) + 0x40\r\n\t\t} else {\r\n\t\t\tthrow new Error('Invalid number ' + number)\r\n\t\t}\r\n\t\tif (offset > bufferSize - 10) {\r\n\t\t\tmakeRoom(0)\r\n\t\t}\r\n\t}\r\n\r\n\tfunction writeBuffer(source) {\r\n\t\tvar sourceLength = source.length\r\n\t\tif (sourceLength + offset + 10 > bufferSize) {\r\n\t\t\tmakeRoom(sourceLength + 10)\r\n\t\t}\r\n\t\tsource.copy(buffer, offset)\r\n\t\toffset += sourceLength\r\n\t}\r\n\r\n\tfunction writeString(string) {\r\n\t\tvar length = string.length\r\n\t\tvar maxStringLength = length * 3 + 10\r\n\t\tif (offset + maxStringLength > bufferSize) {\r\n\t\t\tmakeRoom(maxStringLength + 10)\r\n\t\t}\r\n\t\tvar bytesWritten = encoding ? buffer.write(string, offset, buffer.length, encoding) :\r\n\t\t\tbuffer.utf8Write(string, offset, buffer.length)\r\n\t\toffset += bytesWritten\r\n\t}\r\n\tfunction getSerialized() {\r\n\t\treturn buffer.slice(0, offset)\r\n\t}\r\n\tfunction insertBuffer(headerBuffer, position) {\r\n\t\tvar headerLength = headerBuffer.length\r\n\t\tif (offset + headerLength + 10 > bufferSize) {\r\n\t\t\tmakeRoom(headerLength + 10)\r\n\t\t}\r\n\t\tbuffer.copy(buffer, headerLength + position, position, offset)\r\n\t\theaderBuffer.copy(buffer, position)\r\n\t\toffset += headerLength\r\n\t}\r\n\r\n\tvar encoder = {\r\n\t\twriteToken,\r\n\t\twriteString,\r\n\t\twriteBuffer,\r\n\t\tgetSerialized,\r\n\t\tinsertBuffer,\r\n\t\tflush,\r\n\t\tstartSequence() {\r\n\t\t\tvar currentOffset = offset\r\n\t\t\tbuffer[offset++] = 60\r\n\t\t\tsequences.push(currentOffset)\r\n\t\t\tif (offset > bufferSize - 10) {\r\n\t\t\t\tmakeRoom(0)\r\n\t\t\t}\r\n\t\t},\r\n\t\tendSequence(length) {\r\n\t\t\tvar startOffset = sequences.pop()\r\n\t\t\tif (length < 12 && startOffset > -1) { // if it is short enough, and hasn't been cleared, we can set the beginning byte length\r\n\t\t\t\tbuffer[startOffset] = 48 + length\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tbuffer[offset++] = 62 // else we need to put an end sequence token in\r\n\t\t},\r\n\t\tfinish() {\r\n\t\t\tif (buffer.length - offset > 0x90)\r\n\t\t\t\tavailableBuffers.push(buffer.slice(offset))\r\n\t\t},\r\n\t\tgetOffset() {\r\n\t\t\treturn offset\r\n\t\t},\r\n\t\tsetOffset(newOffset) {\r\n\t\t\toffset = newOffset\r\n\t\t}\r\n\t}\r\n\tif (false) {\r\n\t\tglobal.typeCount = []\r\n\t\tencoder.writeToken = function(type, number) {\r\n\t\t\ttypeCount[type] = (typeCount[type] || 0) + 1\r\n\t\t\twriteToken(type, number)\r\n\t\t}\r\n\t\tglobal.stringCount = new Map()\r\n\t\tencoder.writeString = function(string) {\r\n\t\t\tstringCount.set(string, (stringCount.get(string) || 0) + 1)\r\n\t\t\twriteString(string)\r\n\t\t}\r\n\t\tsetTimeout(function() {\r\n\t\t\tvar stringDuplicationCount = 0\r\n\t\t\tconsole.log('stringCount', Array.from(stringCount).filter(([string, count]) => {\r\n\t\t\t\tif (count > 1 & string.length > 3) {\r\n\t\t\t\t\tstringDuplicationCount += (count - 1) * string.length\r\n\t\t\t\t\treturn true\r\n\t\t\t\t}\r\n\t\t\t}))\r\n\t\t\tconsole.log('stringDuplicationCount', stringDuplicationCount)\r\n\t\t\tconsole.log('typeCount', typeCount)\r\n\t\t})\r\n\t}\r\n\treturn encoder\r\n}\r\nexports.nodeCharEncoder = nodeCharEncoder\r\n", "\"use strict\"\r\nfunction Options() {\r\n\tvar classByName = this.classByName = new Map()\r\n\tthis.converterByConstructor = new Map()\r\n\t//writerByConstructor.set(Map, writeMap)\r\n\t//writerByConstructor.set(Set, writeSet)\r\n}\r\nOptions.prototype.addExtension = function(Class, name, options) {\r\n\tif (name && Class.name !== name) {\r\n\t\tClass.name = name\r\n\t}\r\n\tthis.classByName.set(Class.name, (options && options.fromArray) ? options : Class)\r\n\tthis.converterByConstructor.set(Class, (options && options.toArray) ? options : Class)\r\n}\r\nexports.Options = Options\r\n", "const createSerializer = require('./serialize').createSerializer\r\nconst serialize = require('./serialize').serialize\r\nconst createParser = require('./parse').createParser\r\nconst Options = require('./Options').Options\r\nconst STRING_CODE = 2\r\nvar PROPERTY_CODE = 0\r\nvar NUMBER_CODE = 1\r\nvar TYPE_CODE = 3\r\nvar SEQUENCE_CODE = 7\r\n\r\nvar DEFAULT_TYPE = 6\r\nvar ARRAY_TYPE = 7\r\nvar REFERENCING_TYPE = 8\r\nvar NUMBER_TYPE = 9\r\n\r\nvar NULL = 0 // p\r\n\r\nvar METADATA_TYPE = 11\r\nvar REFERENCING_POSITION = 13\r\nvar TYPE_DEFINITION = 14 // ~  // for defining a typed object without returning the value\r\nvar UNSTRUCTURED_MARKER = 11\r\n\r\nvar OPEN_SEQUENCE = 12 // <\r\nvar END_SEQUENCE = 14 // >\r\n\r\nvar COUNT_THRESHOLD = 2\r\n\r\nexports.createSharedStructure = createSharedStructure\r\nexports.readSharedStructure = readSharedStructure\r\nfunction readSharedStructure(from) {\r\n\tvar parser = createParser()\r\n\tvar sharedProperty = []\r\n\tsharedProperty.code = 6\r\n\tsharedProperty.key = null\r\n\t// end with with NULL (p) value to return something from type definition\r\n\tparser.setSource(from + 'p').read([sharedProperty])\r\n\tsetupShared(sharedProperty)\r\n\tsharedProperty.serialized = from\r\n\treturn sharedProperty\r\n}\r\n\r\nfunction setupShared(property) {\r\n\tproperty.resetTo = property.length\r\n\tproperty.upgrade = upgrade\r\n\tproperty.type = types[property.code]\r\n\tproperty.isFrozen = true\r\n\tObject.defineProperty(property, 'serialized', {\r\n\t\tget() {\r\n\t\t\treturn this._serialized || (this._serialized = serializeSharedStructure(this))\r\n\t\t}\r\n\t})\r\n\r\n\tif (typeof property.values === 'object' && property.values) {\r\n\t\tproperty.values.resetTo = property.values.length\r\n\t\tproperty.lastIndex = property.values.length\r\n\t}\r\n\tfor (var i = 0, l = property.length; i < l; i++) {\r\n\t\tproperty[i].index = i\r\n\t\tproperty[i].resumeIndex = i\r\n\t\tsetupShared(property[i])\r\n\t}\r\n}\r\nfunction startWrite() {\r\n\tfor (var i = 0, l = this.length; i < l; i++) {\r\n\t\tstartWrite.call(this[i])\r\n\t}\r\n\tthis.length = this.resetTo || 0\r\n\tif (typeof this.values === 'object' && this.values) {\r\n\t\tthis.values.length = this.values.resetTo || 0\r\n\t}\r\n}\r\n\r\n\r\n\r\n\t\t// upgrades the property to output this block\r\n\t\t// return 0 if the property was upgraded, or is compatible,\r\n\t\t// 1 if the shared information needs to be written out, but the property was upgraded\r\n\t\t// 2 if the shared information needs to be reserialized\r\nfunction upgrade(property) {\r\n\tif (!property) {\r\n\t\treturn 1\r\n\t}\r\n\tvar compatibility\r\n\tif (property) {\r\n\t\t// same block was serialized last time, fast path to compatility\r\n\t\tif (property.insertedFrom === this && property.insertedVersion === this.version && (\r\n\t\t\t\tproperty.recordUpdate || property.isFrozen || (property.length == 0 && property.code == this.code && property.values == null)\r\n\t\t\t)) {\r\n\t\t\t// but if the version incremented, we need to update\r\n\t\t\treturn 0\r\n\t\t}\r\n\t\tvar changedCode\r\n\t\tif (this.code !== property.code)\r\n\t\t\tchangedCode = true\r\n\t\tif (property.upgrade) {\r\n\t\t\tvar compatibility = copyProperty(this, property)\r\n\t\t\tif (changedCode)\r\n\t\t\t\tcompatibility = 2\r\n\t\t\tif (property.isFrozen && compatibility > 0) {\r\n\t\t\t\treturn 2\r\n\t\t\t}\r\n\t\t\tproperty.insertedFrom = this\r\n\t\t\tproperty.insertedVersion = this.version\r\n\t\t\tif (compatibility === 2) {\r\n\t\t\t\tdebugger\r\n\t\t\t\tconsole.error('Inserting incompatible block into property')\r\n\t\t\t\treturn 2\r\n\t\t\t} else \r\n\t\t\treturn 0\r\n\t\t} else { // upgrading into non-shared property,\r\n\t\t\tproperty.insertedFrom = this\r\n\t\t\tproperty.insertedVersion = this.version\r\n\t\t\t// if this is not a shared property that tracks changes, we have reset and ensure that it doesn't change when we reuse it\r\n\t\t\tproperty.length = 0\r\n\t\t\tproperty.values = null\r\n\t\t\tif (property.fromValue)\r\n\t\t\t\tproperty.fromValue = null\r\n\t\t\treturn 1\r\n\t\t}\r\n\t} else {\r\n\t\tif (this.length > 0) {\r\n\t\t\t// no property, (but block is shared) so just write the buffer with its shared part (if there is one)\r\n\t\t\tblockBuffer = Buffer.concat([this.serialized, blockBuffer])\r\n\t\t}\r\n\t}\r\n\treturn 1\r\n}\r\n\r\nvar typeToCode = {\r\n\tstring: REFERENCING_TYPE,\r\n\tnumber: NUMBER_TYPE,\r\n\tobject: DEFAULT_TYPE,\r\n\tboolean: DEFAULT_TYPE,\r\n\tundefined: DEFAULT_TYPE,\r\n\tarray: ARRAY_TYPE\r\n}\r\n\r\nvar lastPropertyOnObject = new WeakMap()\r\n\r\nfunction createSharedStructure(from, options) {\r\n\tvar instanceProperty = []\r\n\tinstanceProperty.key = null\r\n\tinstanceProperty.code = 6\r\n\tinstanceProperty.type = 'object'\r\n\tlet activeList = []\r\n\tlet needsCleanup = []\r\n\tactiveList.iteration = 0\r\n\tvar previousAvoidShareUpdate\r\n\r\n// property id ranges:\r\n// shared: 0 - 511\r\n// instance: 512+\r\n// shared: \r\n\r\n\tclass Shared extends Array {\r\n\t\tconstructor(instanceProperty) {\r\n\t\t\tsuper()\r\n\t\t\tlet hasUpdates\r\n\t\t\tthis.key = typeof instanceProperty.key == 'string' ? isolateString(instanceProperty.key) : instanceProperty.key\r\n\t\t\tthis.type = instanceProperty.type\r\n\t\t\tthis.code = instanceProperty.code\r\n\t\t\tthis.count = 0\r\n\t\t\tthis.comesAfter = []\r\n\t\t\tif (this.code == REFERENCING_TYPE) {\r\n\t\t\t\tthis.values = []\r\n\t\t\t\tthis.values.resetTo = 512\r\n\t\t\t\tthis.values.nextPosition = 512\r\n\t\t\t\tthis.previousValues = new Map()\r\n\t\t\t\tthis.lastIndex = 0\r\n\t\t\t\tthis.repetitions = 0\r\n\t\t\t}\r\n\t\t}\r\n\t\tnewProperty(instance) {\r\n\t\t\treturn new Shared(instance)\r\n\r\n\t\t}\r\n\t\tgetProperty(value, key, type, extendedType, writeProperty, writeToken, lastPropertyIndex) {\r\n\t\t\tlet property\r\n\t\t\tif (this.insertedFrom) {\r\n\t\t\t\tpropertySearch(this.insertedFrom)\r\n\t\t\t\tif (property) {\r\n\t\t\t\t\tif (lastPropertyIndex !== property.index) {\r\n\t\t\t\t\t\twriteToken(PROPERTY_CODE, propertyIndex)\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn property\r\n\t\t\t\t}\r\n\t\t\t\tif (this.insertedFrom.getProperty) {\r\n\t\t\t\t\t//this.recordUpdate()\r\n\t\t\t\t\treturn this.insertedFrom.getProperty(value, key, type, extendedType, writeProperty, writeToken, lastPropertyIndex)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tdebugger\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.recordUpdate()\r\n\t\t\tlet propertyIndex = this.length\r\n\t\t\tif (lastPropertyIndex !== propertyIndex) {\r\n\t\t\t\twriteToken(PROPERTY_CODE, propertyIndex)\r\n\t\t\t}\r\n\t\t\tif (type === 'boolean' || type === 'undefined') {\r\n\t\t\t\ttype = 'object'\r\n\t\t\t}\r\n\t\t\tproperty = this[propertyIndex] = new Shared({\r\n\t\t\t\tkey,\r\n\t\t\t\ttype,\r\n\t\t\t\tcode: typeToCode[type]\r\n\t\t\t})\r\n\t\t\tproperty.parent = this\r\n\t\t\tproperty.index = propertyIndex\r\n\t\t\treturn property\r\n\t\t\tfunction propertySearch(parentProperty) {\r\n\t\t\t\tlet propertyIndex = -1\r\n\t\t\t\tdo {\r\n\t\t\t\t\tproperty = parentProperty[++propertyIndex]\r\n\t\t\t\t} while(property && (property.key !== key ||\r\n\t\t\t\t\t\t(property.type !== type && type !== 'boolean' && type !== 'undefined') ||\r\n\t\t\t\t\t\t(extendedType && property.extendedType !== constructor)))\r\n\t\t\t}\r\n\t\t}\r\n\t\twriteSharedValue(value, writeToken, serializerId) {\r\n\t\t\t// there are several possible states of a property:\r\n\t\t\t// 1) Non-referencing state (initial state) - We don't reset position indices, and we never reference previous values\r\n\t\t\t// 2) Shared/repetitive state - We can have shared values (<12 position) and we can reference properties in an instance (>=12 position)\r\n\t\t\t// 3) Non-repetitive - If repetition is rare, goes to default type\r\n\t\t\tlet valueEntry = this.previousValues.get(value)\r\n\t\t\tif (valueEntry) {\r\n\t\t\t\tif (valueEntry.serializer == serializerId) {\r\n\t\t\t\t\tthis.repetitions++\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvalueEntry.serializations++\r\n\t\t\t\t\tvalueEntry.serializer = serializerId\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tthis.previousValues.set(value, valueEntry = {\r\n\t\t\t\t\tserializations: 1,\r\n\t\t\t\t\tserializer: serializerId\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\tif (!this.active) {\r\n\t\t\t\tthis.active = 2\r\n\t\t\t\tactiveList.push(this)\r\n\t\t\t}\r\n\t\t\treturn false\r\n\t\t\t/*var index = this.values.length\r\n\t\t\tif (index < 12)\r\n\t\t\t\tthis.values[index] = value*/\r\n\t\t}\r\n\t\tpropertyUsed(property, object, serializerId, i) {\r\n\t\t\tif (property.lastSerializer !== serializerId) {\r\n\t\t\t\tproperty.lastSerializer = serializerId\r\n\t\t\t\tproperty.count++\r\n\t\t\t}\r\n\t\t\tif (i !== 0) {\r\n\t\t\t\tlet lastProperty = lastPropertyOnObject.get(object)\r\n\t\t\t\t// record what has come before so we can order them when creating a common structure\r\n\t\t\t\tif (lastProperty && property.comesAfter.indexOf(lastProperty) === -1)\r\n\t\t\t\t\tproperty.comesAfter.push(lastProperty)\r\n\t\t\t}\r\n\t\t\tlastPropertyOnObject.set(object, property)\r\n\t\t}\r\n\t\trecordUpdate() {\r\n\t\t\tvar property = this\r\n\t\t\tdo {\r\n\t\t\t\tproperty.version = (property.version || 0) + 1\r\n\t\t\t\tif (property.insertedFrom) {\r\n\t\t\t\t\t// or we could try to upgrade the latest inserted property?\r\n\t\t\t\t\tproperty.insertedFrom = null\r\n\t\t\t\t}\r\n\t\t\t\tif (property._serialized)\r\n\t\t\t\t\tproperty._serialized = null\r\n\t\t\t} while(property = property.parent)\r\n\t\t}\r\n\r\n\t\treadingBlock(parse) {\r\n\t\t\t//var blockStructure = this.asBlockStructure()\r\n\t\t\ttry {\r\n\t\t\t\treturn parse()\r\n\t\t\t} finally {\r\n\t\t\t\tthis.readReset()\r\n\t\t\t\tif (this.length > 500) {\r\n\t\t\t\t\tdebugger\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t//active:\r\n\t\t// 0 - not-actively being monitored\r\n\t\t// 1 - being monitored, but an iteration hasn't started for this\r\n\t\t// 2 - being monitored, and an iteration has started\r\n\t\tstartWrite(avoidShareUpdate, value) {\r\n\t\t\tactiveList.iteration++\r\n\t\t\tif (value && value.constructor === Array) {\r\n\t\t\t\tif (this.code !== ARRAY_TYPE && this.version > 0) {\r\n\t\t\t\t\tthrow new Error('Can not change the root type of a shared object to an array')\r\n\t\t\t\t}\r\n\t\t\t\tif (this.code != ARRAY_TYPE)\r\n\t\t\t\t\tthis.recordUpdate()\r\n\t\t\t\tthis.code = ARRAY_TYPE\r\n\t\t\t\tthis.type = 'array'\r\n\t\t\t}\r\n\t\t\tif (this.writing)\r\n\t\t\t\treturn\r\n\t\t\telse\r\n\t\t\t\tthis.writing = true\r\n\t\t\treturn\r\n\t\t\tpreviousAvoidShareUpdate = currentAvoidShareUpdate\r\n\t\t\tif (avoidShareUpdate)\r\n\t\t\t\tcurrentAvoidShareUpdate = true\r\n\t\t}\r\n\t\tendWrite() {\r\n\t\t\tif (this.writing)\r\n\t\t\t\tthis.writing = false\r\n\t\t\telse\r\n\t\t\t\treturn\r\n\r\n\t\t\tlet iterations = this.iterations = (this.iterations || 0) + 1\r\n\t\t\tfor (let i = 0; i < activeList.length; i++) {\r\n\t\t\t\tlet activeSharedProperty = activeList[i]\r\n\t\t\t\tlet previousValues = activeSharedProperty.previousValues\r\n\t\t\t\tif (previousValues && previousValues.size && !activeSharedProperty.isFrozen) {\r\n\t\t\t\t\tif (!currentAvoidShareUpdate) {\r\n\t\t\t\t\t\tif (activeSharedProperty.values.length == 0 &&\r\n\t\t\t\t\t\t\titerations > ((activeSharedProperty.repetitions || 0) + 10) * 5) {\r\n\t\t\t\t\t\t\t// move to permanently non-repetitive\r\n\t\t\t\tconsole.log('changing referenceable to default', activeSharedProperty.key)\r\n\t\t\t\t\t\t\tactiveSharedProperty.previousValues = null\r\n\t\t\t\t\t\t\tactiveSharedProperty.code = DEFAULT_TYPE\r\n\t\t\t\t\t\t\tactiveSharedProperty.type = 'object'\r\n\t\t\t\t\t\t\tactiveSharedProperty.recordUpdate()\r\n\t\t\t\t\t\t\tactiveList.splice(i--, 1)\r\n\t\t\t\t\t\t\tpreviousValues = []\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tfor (let [value, entry] of previousValues) {\r\n\t\t\t\t\t\t\tlet values = activeSharedProperty.values\r\n\t\t\t\t\t\t\tif ((entry.serializations + 3) * 8 < iterations - (entry.startingIteration || (entry.startingIteration = iterations)) || values.length > 500) {\r\n\t\t\t\t\t\t\t\tpreviousValues.delete(value)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (entry.serializations > 50 && entry.serializations * 3 > iterations) {\r\n\t\t\t\t\t\t\t\tvalues[activeSharedProperty.lastIndex++] = value\r\n\t\t\t\t\t\t\t\tactiveSharedProperty.recordUpdate()\r\n\t\t\t\t\t\t\t\tconsole.log('adding value', value, 'to', activeSharedProperty.key)\r\n\t\t\t\t\t\t\t\tpreviousValues.delete(value) // done with tracking, it has been accepted as a common value\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tactiveSharedProperty.active = 0\r\n\t\t\t\t\tactiveList.splice(i--, 1)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (activeList.hasUpdates) {\r\n\t\t\t\tactiveList.hasUpdates = false\r\n\t\t\t\tthis.version++\r\n\t\t\t\tif (!this._serialized)\r\n\t\t\t\t\tthis._serialized = null\r\n\t\t\t\tif (options && options.onUpdate)\r\n\t\t\t\t\toptions.onUpdate()\r\n\t\t\t}\r\n\t\t\tcurrentAvoidShareUpdate = previousAvoidShareUpdate\r\n\t\t}\r\n\r\n\t\tupgrade(property) {\r\n\t\t\treturn upgrade.call(this, property)\r\n\t\t}\r\n\r\n\t\tget serialized() {\r\n\t\t\treturn this._serialized || (this._serialized = serializeSharedStructure(this))\r\n\t\t}\r\n\t\tserializeCommonStructure(embedded) {\r\n\t\t\tvar usageThreshold = Math.sqrt(activeList.iteration)\r\n\t\t\treturn serializeSharedStructure(this, childProperty => childProperty.count >= usageThreshold, embedded)\r\n\t\t}\r\n\t}\r\n\r\n\tvar sharedStructure = new Shared(instanceProperty)\r\n\tsharedStructure.version = 0\r\n\r\n\tsharedStructure.freeze = function() {\r\n\t\tthis.isFrozen = true\r\n\t\tthis.reset()\r\n\t}\r\n\r\n\tif (from) {\r\n\t\tvar parser = createParser({\r\n\t\t\tforDeferred(block, property) {\r\n\t\t\t\tproperty.isBlock = true\r\n\t\t\t\treturn block\r\n\t\t\t},\r\n\t\t\tparseDeferreds: true\r\n\t\t})\r\n\t\t// concatenate shared structure with null so there is a value to parse\r\n\t\tvar readProperty = []\r\n\t\treadProperty.code = 6\r\n\t\treadProperty.key = null\r\n\t\t// end with with NULL (p) value to return something from type definition\r\n\t\tparser.setSource(from + 'p').read([readProperty])\r\n\t\tcopyProperty(readProperty, sharedStructure)\r\n\t\tactiveList.hasUpdates = false\r\n\t\tsharedStructure.version = 1\r\n\t}\r\n\tsharedStructure.key = null // root must be null (for the parser to work properly)\r\n\r\n\treturn sharedStructure\r\n}\r\n\r\nfunction isDescendant(property, possibleParent) {\r\n\tdo {\r\n\t\tif (property === possibleParent)\r\n\t\t\treturn true\r\n\t} while (property = property.parent)\r\n}\r\n// default type for each code\r\nvar types = {\r\n\t6/*DEFAULT_TYPE*/: 'object',\r\n\t7/*ARRAY_TYPE*/: 'array',\r\n\t8/*REFERENCING_TYPE*/: 'string',\r\n\t9/*NUMBER_TYPE*/: 'number'\r\n}\r\n\r\nvar currentAvoidShareUpdate\r\nfunction serializeSharedStructure(property, condition, embedded) {\r\n\tvar serializer = createSerializer()\r\n\tvar writers = serializer.getWriters()\r\n\tserializeSharedProperty(property, !embedded, !embedded)\r\n\tfunction serializeSharedProperty(property, expectsObjectWithNullKey, isRoot) {\r\n\t\tif (property.insertedFrom && property.insertedFrom.serializeCommonStructure) {\r\n\t\t\tproperty = property.insertedFrom\r\n\t\t\treturn writers.writeBuffer(property.serializeCommonStructure(!isRoot))\r\n\t\t}\r\n\t\tvar isArray = property.code === ARRAY_TYPE\r\n\t\tvar commonProperties = condition ? orderProperties(property.filter(condition)) : property\r\n\t\tvar length = commonProperties.length\r\n\t\tif (!(expectsObjectWithNullKey && property.code === DEFAULT_TYPE)) {\r\n\t\t\tlet key = isRoot ? null : property.key\r\n\t\t\twriters.writeProperty(key, types[property.code])\r\n\t\t\tif (length === 0 && key === null && (property.code === DEFAULT_TYPE || property.code === ARRAY_TYPE)) {\r\n\t\t\t\t// the key was elided, but won't be followed by sequence, so write one now\r\n\t\t\t\twriters.writeToken(SEQUENCE_CODE, 0)\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (isRoot && length > 0) {\r\n\t\t\twriters.writeToken(TYPE_CODE, TYPE_DEFINITION)\r\n\t\t}\r\n\t\tif (length > 0) {\r\n\t\t\t// we always use open sequence, because writing multiple values of a property use extra property counts,\r\n\t\t\t// plus it is easier to deal with properties without values\r\n\t\t\twriters.writeToken(SEQUENCE_CODE, OPEN_SEQUENCE)\r\n\t\t\tfor (var i = 0; i < length; i++) {\r\n\t\t\t\tvar childProperty = commonProperties[i]\r\n\t\t\t\tchildProperty.index = i\r\n\t\t\t\tif (isArray && i > 0) {\r\n\t\t\t\t\twriters.writeToken(PROPERTY_CODE, i)\r\n\t\t\t\t}\r\n\t\t\t\tserializeSharedProperty(childProperty, commonProperties.code === ARRAY_TYPE && i === 0, false, condition)\r\n\t\t\t}\r\n\t\t\twriters.writeToken(SEQUENCE_CODE, END_SEQUENCE)\r\n\t\t}\r\n\t\tvar first = true\r\n/*\t\tif (property.previousValues) {\r\n\t\t\tfor (let [value, count] of property.previousValues) {\r\n\t\t\t\tif (count >= usageThreshold * 2) {\r\n\t\t\t\t\tif (first)\r\n\t\t\t\t\t\tfirst = false\r\n\t\t\t\t\telse // reset property code for each subsequent value so we don't move on to the next property in parsing\r\n\t\t\t\t\t\twriters.writeToken(PROPERTY_CODE, property.index)\r\n\t\t\t\t\twriters.writeAsDefault(value)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else */\r\n\t\tif (property.lastIndex > 0) {\r\n\t\t\tfor (var i = 0, l = property.lastIndex; i < l; i++) {\r\n\t\t\t\tvar value = property.values[i]\r\n\t\t\t\tif (first)\r\n\t\t\t\t\tfirst = false\r\n\t\t\t\telse // reset property code for each subsequent value so we don't move on to the next property in parsing\r\n\t\t\t\t\twriters.writeToken(PROPERTY_CODE, property.index)\r\n\t\t\t\twriters.writeAsDefault(value)\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}\r\n\tlet serialized = serializer.getSerialized()\r\n\treturn serialized\r\n}\r\nfunction copyProperty(source, target, freezeTarget, startingIndex) {\r\n\tvar compatibility = 0\r\n\ttarget.code = source.code\r\n\ttarget.type = source.type || types[source.code]\r\n\tif (freezeTarget) {\r\n\t\ttarget.isFrozen = true\r\n\t\tif (target.previousValues)\r\n\t\t\ttarget.previousValues = null\r\n\t}\r\n\tlet sourceLength = source.resetTo > -1 ? source.resetTo : source.length\r\n\tif (target.resetTo > -1 && target.resetTo < target.length)\r\n\t\ttarget.length = target.resetTo\r\n\tfor (var i = startingIndex || 0; i < sourceLength; i++) {\r\n\t\tvar targetChild = target[i]\r\n\t\tvar childProperty = source[i]\r\n\t\tif (targetChild && (targetChild.key != childProperty.key || targetChild.extendedType != childProperty.extendedType ||\r\n\t\t\ttargetChild.code != childProperty.code &&\r\n\t\t\t\t!(targetChild.code == 8 && childProperty.code === 6 && (!targetChild.values || !targetChild.values.length)))) { // ok to upgrade from string to default\r\n\t\t\tif (target.isFrozen)\r\n\t\t\t\treturn 2\r\n\t\t\tcompatibility = 2\r\n\t\t}\r\n\t\tif (!targetChild) {\r\n\t\t\tif (target.isFrozen)\r\n\t\t\t\treturn 2\r\n\t\t\tvar targetChild = []\r\n\t\t\ttargetChild.code = childProperty.code\r\n\t\t\tif (target.newProperty) {\r\n\t\t\t\ttargetChild = target.newProperty(targetChild)\r\n\t\t\t}\r\n\t\t\ttarget[i] = targetChild\r\n\t\t\tif (childProperty.metadata)\r\n\t\t\t\ttargetChild.metadata = childProperty.metadata\r\n\t\t\tif (childProperty.insertedFrom) {\r\n\t\t\t\ttargetChild.insertedFrom = childProperty.insertedFrom\r\n\t\t\t\ttargetChild.insertedVersion = childProperty.insertedVersion\r\n\t\t\t}\r\n\t\t\ttargetChild.parent = target\r\n\t\t}\r\n\t\ttargetChild.key = childProperty.key\r\n\r\n// TODO: Check to make sure the values are compatible\r\n\t\tif (childProperty.values && childProperty.values.length > 0) {\r\n\t\t\tif (childProperty.values.resetTo > -1) {\r\n\t\t\t\tchildProperty.values.length = childProperty.values.resetTo\r\n\t\t\t}\r\n\t\t\tif (!targetChild.values || childProperty.values.length > (targetChild.values.resetTo > -1 ? targetChild.values.resetTo : targetChild.values.length)) {\r\n\t\t\t\ttargetChild.values = childProperty.values.slice(0)\r\n\t\t\t\ttargetChild.values.nextPosition = childProperty.values.length\r\n\t\t\t\tif (targetChild.values.length >= 12) {\r\n\t\t\t\t\ttargetChild.previousValues = null\r\n\t\t\t\t}\r\n\t\t\t\tif (compatibility == 0) {\r\n\t\t\t\t\tcompatibility = 1\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar childCompatibility = copyProperty(childProperty, targetChild, freezeTarget)\r\n\t\tif (childCompatibility > compatibility)\r\n\t\t\tcompatibility = childCompatibility\r\n\t}\r\n\tlet targetLength = target.resetTo > -1 ? target.resetTo : target.length\r\n\tif (targetLength > sourceLength) {\r\n\t\tif (target.recordUpdate) {\r\n\t\t\t// reverse freeze if the target has more values, we don't want the source becoming incompatible\r\n\t\t\tsource.metadata = UNSTRUCTURED_MARKER\r\n\t\t\tsource.recordUpdate()\r\n\t\t} else if (target.isFrozen) {\r\n\t\t\treturn 2\r\n\t\t}\r\n\t\t// merge back to the source if there are extra properties on the target\r\n\t\t//copyProperty(target, source, i)\r\n\t\t//source.recordUpdate()\r\n\t}\r\n\t/*if (target.previousValues) {\r\n\t\ttarget.values = target.previousValues\r\n\t\ttarget.previousValues = []\r\n\t}*/\r\n\t//target.length = source.length\r\n\treturn compatibility\r\n}\r\n\r\n// return values:\r\n// 0: identical property structures\r\n// -1: a has less properties, but can be safely upgraded to b and still be compatible with a\r\n// 1: a has more properties, but is compatible and can be used to decode b\r\n// -2: incompatible property structures, can not be used\r\nfunction isCompatibleProperty(a, b) {\r\n\tif (a.blockStructure === b) {\r\n\t\treturn a.version > b.version ? 1 : 0\r\n\t}\r\n\tif (a.code === b.code && a.extendedType === b.extendedType) {\r\n\t\tvar sharedLength = Math.min(a.length, b.length)\r\n\t\tvar compatibility = 0\r\n\t\tfor (var i = 0; i < sharedLength; i++) {\r\n\t\t\tif (a[i].key !== b[i].key)\r\n\t\t\t\treturn -2\r\n\t\t\tvar childCompatibility = isCompatibleProperty(a[i], b[i])\r\n\t\t\tif (childCompatibility === -2)\r\n\t\t\t\treturn -2\r\n\t\t\tif (childCompatibility === -1) {\r\n\t\t\t\tif (compatibility === 1)\r\n\t\t\t\t\treturn -2\r\n\t\t\t\tcompatibility = -1\r\n\t\t\t}\r\n\t\t\tif (childCompatibility === 1) {\r\n\t\t\t\tif (compatibility === -1)\r\n\t\t\t\t\treturn -2\r\n\t\t\t\tcompatibility = 1\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar sharedValuesLength = Math.min(a.values ? a.values.length : 0, b.values ? b.values.length : 0)\r\n\t\tfor (var i = 0; i < sharedValuesLength; i++) {\r\n\t\t\tif (a.values[i] !== b.values[i]) {\r\n\t\t\t\treturn -2\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (a.length < b.length) {\r\n\t\t\tif (compatibility === 1) {\r\n\t\t\t\treturn -2\r\n\t\t\t}\r\n\t\t\tcompatibility = -1\r\n\t\t} else if (a.length < b.length) {\r\n\t\t\tif (compatibility === -1) {\r\n\t\t\t\treturn -2\r\n\t\t\t}\r\n\t\t\tcompatibility = 1\r\n\t\t}\r\n\t\t/*if (a.values.length < b.values.length) {\r\n\t\t\tif (compatibility === 1) {\r\n\t\t\t\treturn -2\r\n\t\t\t}\r\n\t\t\tcompatibility = -1\r\n\t\t} else if (a.values.length < b.values.length) {\r\n\t\t\tif (compatibility === -1) {\r\n\t\t\t\treturn -2\r\n\t\t\t}\r\n\t\t\tcompatibility = 1\r\n\t\t}*/\r\n\t\treturn compatibility\r\n\t} else {\r\n\t\treturn -2\r\n\t}\r\n}\r\n\r\nfunction isolateString(string) {\r\n\t// this is a technique to forcefully recreate a string so it isn't a slice of a larger string. Because shared\r\n\t// structures are long-lived and created from instance structures that are short-lived, the long-lived small\r\n\t// sliced strings can end up pinning (otherwise short-lived) large strings in memory.\r\n\treturn string.slice(0, 1) + string.slice(1)\r\n}\r\n\r\n// order properties by their comesAfter list, to ensure each properties comes after everything in their comesAfter list\r\nfunction orderProperties(properties) {\r\n\tvar ordered = []\r\n\tvar traversed = new Set()\r\n\tfunction addProperty(property) {\r\n\t\tif (traversed.has(property)) // do this first in case of circular ordering\r\n\t\t\treturn\r\n\t\ttraversed.add(property)\r\n\t\tfor (var propertyBefore of property.comesAfter) {\r\n\t\t\taddProperty(propertyBefore)\r\n\t\t}\r\n\t\tordered.push(property)\r\n\t}\r\n\tfor (let property of properties) {\r\n\t\taddProperty(property)\r\n\t}\r\n\treturn ordered\r\n}", "\"use strict\"\r\nconst BLOCK_TYPE = 5\r\nvar makeSymbol = typeof Symbol !== 'undefined' ? Symbol : function(name) {\r\n\treturn 'symbol-' + name\r\n}\r\n\r\n/*\r\nTwo types of blocks, frozen and copy-on-write\r\nFrozen - originating from JS objects\r\n\tObject.freeze() js objects and use symbol for serialized representation\r\nFrozen - originating from dpack, lazy evaluation\r\n\tProxy - get,has,etc. triggers parse, set throws\r\nCopy-on-write from JS objects\r\n\tProxy - get,has,etc. retrieves from source JS object, set copies\r\nCopy-on-write originating from dpack\r\n\tSame\r\n*/\r\n\r\nvar nextVersion = 1\r\nvar bufferSymbol = makeSymbol('buffer')\r\nvar sizeTableSymbol = makeSymbol('sizeTable')\r\nvar headerSymbol = makeSymbol('header')\r\nvar parsedSymbol = makeSymbol('parsed')\r\nvar sharedSymbol = makeSymbol('shared')\r\nvar targetSymbol = makeSymbol('target')\r\nconst freezeObjects = process.env.NODE_ENV != 'production'\r\n\r\nvar DEFAULT_TYPE = 6\r\nvar ARRAY_TYPE = 7\r\n\r\n/*\r\nsize table size types in first 2 bits:\r\n\r\nfirst byte\r\n0 - leaf mode, 6 bit length\r\n1 - leaf mode, 14 bit length\r\n2 - branch/leaf mode, 14, 16, 16 bit our-size length\r\n3 - branch/leaf mode, 30, 48, 48 bit our-size length\r\n*/\r\nfunction Block() {}\r\nvar serializeModule = require('./serialize')\r\n\r\nexports.Block = Block\r\nexports.bufferSymbol = serializeModule.bufferSymbol = bufferSymbol\r\nexports.parsedSymbol = parsedSymbol\r\nexports.sharedSymbol = sharedSymbol\r\nexports.targetSymbol = serializeModule.targetSymbol = targetSymbol\r\nexports.sizeTableSymbol = serializeModule.sizeTableSymbol = sizeTableSymbol\r\nvar serialize = serializeModule.serialize\r\nvar createSerializer = serializeModule.createSerializer\r\nexports.asBlock = asBlock\r\nfunction asBlock(object, shared) {\r\n\tif (object && object[targetSymbol]) {\r\n\t\treturn object // already a block\r\n\t}\r\n\tif (Array.isArray(object)) {\r\n\t\t// if the object is an array, make the taget an array so it passes Array.isArray checks\r\n\t\tlet target = []\r\n\t\ttarget.parsed = object\r\n\t\ttarget.shared = shared\r\n\t\treturn new Proxy(target, onDemandHandler)\r\n\t}\r\n\treturn new Proxy({\r\n\t\tparsed: object,\r\n\t\tshared: shared\r\n\t}, onDemandHandler)\r\n}\r\nexports.isBlock = isBlock\r\nfunction isBlock(object) {\r\n\treturn object && object[targetSymbol]\r\n}\r\n\r\nexports.makeBlockFromBuffer = makeBlockFromBuffer\r\nfunction makeBlockFromBuffer(buffer, shared) {\r\n\tvar dpackBuffer, sizeTableBuffer\r\n\tif (buffer[0] < 0x80) {\r\n\t\tdpackBuffer = buffer\r\n\t} else { // a branch type will always be greater than 0x80\r\n\t\tvar type = buffer[0] >> 6\r\n\t\tvar dpackOffset\r\n\t\tif (type === 2) {\r\n\t\t\tdpackOffset = buffer.readUInt16BE(0) & 0x3fff\r\n\t\t} else {\r\n\t\t\tdpackOffset = buffer.readUInt32BE(0) & 0x3fffffff\r\n\t\t}\r\n\t\tdpackBuffer = buffer.slice(dpackOffset)\r\n\t\tsizeTableBuffer = buffer.slice(0, dpackOffset)\r\n\t}\r\n\r\n\tvar target = {\r\n\t\tdpackBuffer: dpackBuffer,\r\n\t\tsizeTableBuffer: sizeTableBuffer,\r\n\t\tshared: shared,\r\n\t\treassign: function(buffer) { // TODO: don't create each time\r\n\t\t\tthis.buffer = buffer\r\n\t\t}\r\n\t}\r\n\tbuffer.owner = target\r\n\treturn new Proxy(target, onDemandHandler)\r\n}\r\n\r\nexports.getLazyHeader = function(block) {\r\n\treturn block[sizeTableSymbol]\r\n}\r\n\r\nvar onDemandHandler = {\r\n\tget: function(target, key) {\r\n\t\tif (specialGetters.hasOwnProperty(key)) {\r\n\t\t\treturn specialGetters[key].call(target)\r\n\t\t}\r\n\t\tvar parsed = target.parsed\r\n\t\tif (!parsed) {\r\n\t\t\tparsed = getParsed(target)\r\n\t\t}\r\n\t\treturn parsed[key]\r\n\t},\r\n\tset: function(target, key, value) {\r\n\t\t// we allow symbols to set as a form of metadata objects even though the main string keyed properties are frozen\r\n\t\tif (typeof key === 'symbol') {\r\n\t\t\ttarget[key] = value\r\n\t\t\tmakeSymbolGetter(key)\r\n\t\t\treturn true\r\n\t\t}\r\n\t\tthrow new Error('No changes are allowed on frozen parsed object, Use dpack copy() function to modify')\r\n\t},\r\n\tdeleteProperty: function() {\r\n\t\tthrow new Error('No changes are allowed on frozen parsed object, Use dpack copy() function to modify')\r\n\t},\r\n\tgetOwnPropertyDescriptor: function(target, key) {\r\n\t\tvar parsed = getParsed(target)\r\n\t\treturn Object.getOwnPropertyDescriptor(parsed, key)\r\n\t},\r\n\thas: function(target, key) {\r\n\t\tvar parsed = getParsed(target)\r\n\t\treturn key in parsed\r\n\t},\r\n\townKeys: function(target) {\r\n\t\tvar parsed = getParsed(target)\r\n\t\tvar keys = Object.keys(parsed)\r\n\t\tif (Array.isArray(parsed)) {\r\n\t\t\tkeys.push('length')\r\n\t\t}\r\n\t\treturn keys\r\n\t},\r\n\tgetPrototypeOf: function(target) {\r\n\t\tvar parsed = getParsed(target)\r\n\t\treturn Object.getPrototypeOf(parsed)\r\n\t}\r\n}\r\n\r\nexports.reassignBuffers = reassignBuffers\r\nfunction reassignBuffers(block, newParentNodeBuffer, parentArrayBuffer) {\r\n\t\t// if a buffer needs to be moved to a new buffer due to it soon being no longer referenceable, we can reference the new copy\r\n\t\tvar target = block[targetSymbol]\r\n\t\tvar buffer = target.dpackBuffer\r\n\t\tif (!parentArrayBuffer)\r\n\t\t\tparentArrayBuffer = buffer.buffer\r\n\t\tif (buffer && buffer.buffer === parentArrayBuffer) {\r\n\t\t\tvar byteOffset = buffer.byteOffset\r\n\t\t\ttarget.dpackBuffer = newParentNodeBuffer.slice(byteOffset, byteOffset + buffer.length)\r\n\t\t}\r\n\t\tvar buffer = target.sizeTableBuffer\r\n\t\tif (buffer && buffer.buffer === parentArrayBuffer) {\r\n\t\t\tvar byteOffset = buffer.byteOffset\r\n\t\t\ttarget.sizeTableBuffer = newParentNodeBuffer.slice(byteOffset, byteOffset + buffer.length)\r\n\t\t}\r\n\t\tif (target.parsed) {\r\n\t\t\tvar parsed = target.parsed\r\n\t\t\tfor (var key in parsed) {\r\n\t\t\t\tvar value = parsed[key]\r\n\t\t\t\tif (isBlock(value)) {\r\n\t\t\t\t\treassignBuffers(value, newParentNodeBuffer, parentArrayBuffer)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\nvar copyOnWriteHandler = {\r\n\tget: function(target, key) {\r\n\t\tif (specialGetters.hasOwnProperty(key)) {\r\n\t\t\treturn specialGetters[key].call(target)\r\n\t\t}\r\n\t\tvar cachedParsed = target.cachedParsed\r\n\t\tif (cachedParsed && cachedParsed.hasOwnProperty(key) && !(key == 'length' && Array.isArray(cachedParsed))) {\r\n\t\t\treturn cachedParsed[key]\r\n\t\t}\r\n\t\tvar parsed = target.parsed\r\n\t\tif (!parsed) {\r\n\t\t\tparsed = getParsed(target)\r\n\t\t}\r\n\t\tvar value = parsed[key]\r\n\t\t/*if (value && typeof value == 'object') {\r\n\t\t\tif (!cachedParsed) {\r\n\t\t\t\ttarget.cachedParsed = cachedParsed = parsed instanceof Array ? [] : {}\r\n\t\t\t}\r\n\t\t\tif (value instanceof Map)\r\n\t\t\t\tcachedParsed[key] = value\r\n\t\t\telse\r\n\t\t\t\tcachedParsed[key] = value = copyWithParent(value, target)\r\n\t\t}*/\r\n\t\tif (value && value[targetSymbol]) {\r\n\t\t\tif (!cachedParsed) {\r\n\t\t\t\ttarget.cachedParsed = cachedParsed = parsed instanceof Array ? [] : {}\r\n\t\t\t}\r\n\t\t\tcachedParsed[key] = value = copyWithParent(value, target)\r\n\t\t}\r\n\t\treturn value\r\n\t},\r\n\tchanged: function(target) {\r\n\t\ttarget.dpackBuffer = null\r\n\t\ttarget.sizeTableBuffer = null\r\n\t\ttarget.shared = null\r\n\t\tvar parsed = target.parsed\r\n\t\tif (!parsed) {\r\n\t\t\tparsed = getParsed(target)\r\n\t\t}\r\n\t\tif (!target.copied) {\r\n\t\t\tvar cachedParsed = target.cachedParsed\r\n\t\t\tvar copied = target.parsed = target.cachedParsed = parsed instanceof Array ? [] : {}\r\n\t\t\tfor (var key in parsed) {\r\n\t\t\t\tvar value = cachedParsed && cachedParsed[key]\r\n\t\t\t\tif (!value) {\r\n\t\t\t\t\tvalue = parsed[key]\r\n\t\t\t\t\tif (value && value[targetSymbol]) {\r\n\t\t\t\t\t\tvalue = copyWithParent(value, target)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tcopied[key] = value\r\n\t\t\t}\r\n\t\t\tparsed = copied\r\n\t\t\ttarget.copied = true\r\n\t\t}\r\n\t\ttarget.version = nextVersion++\r\n\t\treturn parsed\r\n\t},\r\n\tcheckVersion: function(target) {\r\n\t\tvar cachedParsed = target.cachedParsed\r\n\t\tlet version = target.version || 0\r\n\t\tif (cachedParsed) {\r\n\t\t\tfor (let key in cachedParsed) {\r\n\t\t\t\tvar value = cachedParsed[key]\r\n\t\t\t\tif (value && value[targetSymbol]) {\r\n\t\t\t\t\tversion = Math.max(version, this.checkVersion(value[targetSymbol]))\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (version != (target.version || 0)) {\r\n\t\t\tthis.changed(target)\r\n\t\t\ttarget.version = version\r\n\t\t}\r\n\t\treturn version\r\n\t},\r\n\tset: function(target, key, value, proxy) {\r\n\t\tif (specialSetters.hasOwnProperty(key)) {\r\n\t\t\tspecialSetters[key].call(target, value)\r\n\t\t\treturn true\r\n\t\t}\r\n\t\tvar parsed = copyOnWriteHandler.changed(target)\r\n\t\tparsed[key] = value\r\n\t\treturn true\r\n\t},\r\n\tdeleteProperty: function(target, key) {\r\n\t\tvar parsed = copyOnWriteHandler.changed(target)\r\n\t\treturn delete parsed[key]\r\n\t},\r\n\tgetOwnPropertyDescriptor: function(target, key) {\r\n\t\tvar parsed = getParsed(target)\r\n\t\treturn Object.getOwnPropertyDescriptor(parsed, key)\r\n\t},\r\n\thas: function(target, key) {\r\n\t\tvar parsed = getParsed(target)\r\n\t\treturn key in parsed\r\n\t},\r\n\townKeys: function(target) {\r\n\t\tvar parsed = getParsed(target)\r\n\t\tvar keys = Object.keys(parsed)\r\n\t\tif (Array.isArray(parsed)) {\r\n\t\t\tkeys.push('length')\r\n\t\t}\r\n\t\tif (target.copied) {\r\n\t\t\tfor (var key in target.copied) {\r\n\t\t\t\tif (keys.indexOf(key) === -1) {\r\n\t\t\t\t\tkeys.push(key)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn keys\r\n\t},\r\n\tgetPrototypeOf: function(target) {\r\n\t\tvar parsed = getParsed(target)\r\n\t\treturn Object.getPrototypeOf(parsed)\r\n\t}\r\n}\r\n\r\nvar specialGetters = {\r\n}\r\nspecialGetters[bufferSymbol] = function() {\r\n\treturn function(property, randomAccess) {\r\n\t\tvar propertyIsShared = property && property.upgrade\r\n\t\tvar buffer\r\n\r\n\t\tif (this.cachedParsed && this.dpackBuffer) {\r\n\t\t\tcopyOnWriteHandler.checkVersion(this)\r\n\t\t}\r\n\t\tif (!(this.shared && this.shared.upgrade) && propertyIsShared) {\r\n\t\t\tif (this.dpackBuffer) {\r\n\t\t\t\t// if the block has been serialized without a shared structure, and it will be used in a shared structure,\r\n\t\t\t\t// we put it in a separate property\r\n\t\t\t\tthis.sizeTableBuffer = null\r\n\t\t\t\treturn inSeparateProperty(this.dpackBuffer, true)\r\n\t\t\t} else {\r\n\t\t\t\treturn getSerialized(this, this.shared = property)\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!this.dpackBuffer) {\r\n\t\t\tgetSerialized(this, this.shared)\r\n\t\t}\r\n\t\tif (this.shared && this.shared.upgrade && this.shared !== property) {\r\n\t\t\tvar compatibility = this.shared.upgrade(property, randomAccess)\r\n\t\t\tif (compatibility > 0) {\r\n\t\t\t\t// if the property upgrade was incompatible, we have to included the shared structure, and force sequential reading\r\n\t\t\t\tthis.sizeTableBuffer = null\r\n\t\t\t\tvar sharedBuffer = this.shared.serialized\r\n\t\t\t\tif (sharedBuffer.length > 0) {\r\n\t\t\t\t\tif (compatibility == 2 && !(property.isFrozen && property.resetTo === 0))\r\n\t\t\t\t\t\tsharedBuffer = inSeparateProperty(sharedBuffer)\r\n\t\t\t\t\tbuffer = Buffer.concat([sharedBuffer, this.dpackBuffer])\r\n\t\t\t\t\tbuffer.mustSequence = true\r\n\t\t\t\t\treturn buffer\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (property) {\r\n\t\t\tif (!propertyIsShared) {\r\n\t\t\t\t// need to reset this property, if it is a plain sequential property\r\n\t\t\t\tproperty.length = 0\r\n\t\t\t}\r\n\t\t\tif (property.insertedFrom)\r\n\t\t\t\tproperty.insertedFrom = null\r\n\t\t}\r\n\t\treturn this.dpackBuffer\r\n\r\n\t\tfunction inSeparateProperty(dpackBuffer) {\r\n\t\t\tvar serializer = createSerializer()\r\n\t\t\tvar isArray = dpackBuffer[0] === 119\r\n\t\t\tvar writeToken = serializer.getWriters().writeToken\r\n\t\t\tif (isArray) {\r\n\t\t\t\tdpackBuffer = dpackBuffer.slice(1) // replacing the property declaration\r\n\t\t\t}\r\n\t\t\twriteToken(0, 1000)// use a hopefully unused slot (should be unused, block always has a single initial starting slot)\r\n\t\t\twriteToken(3, isArray ? ARRAY_TYPE : DEFAULT_TYPE) // property type\r\n\t\t\tif (property && property.key !== null)\r\n\t\t\t\tserializer.serialize(property.key)\r\n\t\t\tdpackBuffer = Buffer.concat([serializer.getSerialized(), dpackBuffer])\r\n\t\t\tdpackBuffer.mustSequence = true\r\n\t\t\treturn dpackBuffer\r\n\t\t}\r\n\r\n\t}.bind(this)\r\n}\r\nspecialGetters[targetSymbol] = function() {\r\n\treturn this\r\n}\r\nspecialGetters[sharedSymbol] = function() {\r\n\treturn this.shared\r\n}\r\nspecialGetters[parsedSymbol] = function() {\r\n\treturn this.parsed || getParsed(this)\r\n}\r\nspecialGetters[sizeTableSymbol] = function() {\r\n\tif (!this.dpackBuffer) {\r\n\t\tgetSerialized(this)\r\n\t}\r\n\treturn this.sizeTableBuffer\r\n}\r\nspecialGetters.then = function() {\r\n\t// return undefined, this is not a promise\r\n}\r\nspecialGetters.toJSON = function() {\r\n\treturn valueOf\r\n}\r\n\r\nspecialGetters.valueOf = function() {\r\n\treturn valueOf\r\n}\r\nspecialGetters.entries = function() {\r\n\treturn entries\r\n}\r\nfunction entries() {\r\n\treturn this[parsedSymbol].entries()\r\n}\r\nspecialGetters[Symbol.iterator] = function() {\r\n\tvar parsed = this.parsed || getParsed(this)\r\n\treturn parsed && parsed[Symbol.iterator] && iterator\r\n}\r\nfunction iterator() {\r\n\tvar parsed = this[parsedSymbol]\r\n\treturn parsed && parsed[Symbol.iterator] ? parsed[Symbol.iterator]() : [][Symbol.iterator]()\r\n}\r\nspecialGetters.constructor = function() {\r\n\tif (this.parsed) {\r\n\t\treturn this.parsed.constructor\r\n\t}\r\n\t// this is a fast path for getting the constructor without having to parse. this is important\r\n\t// as it enables blocks to be go through the serializer, have it check the constructor, without\r\n\t// requiring parsing, and then they can be directly written from their binary buffer\r\n\tif (this.dpackBuffer) {\r\n\t\tlet firstByte = this.dpackBuffer[0]\r\n\t\tif (firstByte >= 48 && firstByte <= 60) {\r\n\t\t\t// sequence\r\n\t\t\tif (this.shared) {\r\n\t\t\t\tif (this.shared.code == DEFAULT_TYPE) {\r\n\t\t\t\t\treturn Object\r\n\t\t\t\t} else if (this.shared.code == ARRAY_TYPE) {\r\n\t\t\t\t\treturn Array\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\treturn Object\r\n\t\t\t}\r\n\t\t} else if (firstByte === 119) {\r\n\t\t\treturn Array\r\n\t\t}\r\n\t}\r\n\treturn getParsed(this).constructor\r\n}\r\n\r\n\r\nfunction makeSymbolGetter(symbol) {\r\n\tif (!specialGetters[symbol])\r\n\t\tspecialGetters[symbol] = function() {\r\n\t\t\treturn this[symbol]\r\n\t\t}\r\n}\r\nfunction valueOf() {\r\n\treturn this[parsedSymbol]\r\n}\r\nfunction copy(source) {\r\n\treturn copyWithParent(source)\r\n}\r\nfunction copyWithParent(source, parent) {\r\n\tif (!isBlock(source)) {\r\n\t\t/*if (source && typeof source == 'object')\r\n\t\t\tsource = asBlock(source)\r\n\t\telse*/\r\n\t\t\treturn source\r\n\t}\r\n\tlet isArray = Array.isArray(source)\r\n\tlet target = isArray ? [] : {}\r\n\tObject.defineProperties(target, {\r\n\t\tparsed: {\r\n\t\t\tget() {\r\n\t\t\t\treturn source[parsedSymbol]\r\n\t\t\t},\r\n\t\t\tset(value) {\r\n\t\t\t\tObject.defineProperty(this, 'parsed', {\r\n\t\t\t\t\tvalue: value,\r\n\t\t\t\t\twritable: true,\r\n\t\t\t\t\tenumerable: true\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tconfigurable: true,\r\n\t\t},\r\n\t\tshared: {\r\n\t\t\tget() {\r\n\t\t\t\treturn source[sharedSymbol]\r\n\t\t\t},\r\n\t\t\tset(value) {\r\n\t\t\t\tObject.defineProperty(this, 'shared', {\r\n\t\t\t\t\tvalue: value,\r\n\t\t\t\t\twritable: true,\r\n\t\t\t\t\tenumerable: true\r\n\t\t\t\t})\r\n\t\t\t\tthis.dpackBuffer = null\r\n\t\t\t\tthis.sizeTableBuffer = null\r\n\t\t\t},\r\n\t\t\tconfigurable: true,\r\n\t\t},\r\n\t\tdpackBuffer: {\r\n\t\t\tget() {\r\n\t\t\t\treturn source[targetSymbol].dpackBuffer\r\n\t\t\t},\r\n\t\t\tset(value) {\r\n\t\t\t\tObject.defineProperty(this, 'dpackBuffer', {\r\n\t\t\t\t\tvalue: value,\r\n\t\t\t\t\twritable: true,\r\n\t\t\t\t\tenumerable: true\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tconfigurable: true,\r\n\t\t},\r\n\t\tsizeTableBuffer: {\r\n\t\t\tget() {\r\n\t\t\t\treturn source[sizeTableSymbol]\r\n\t\t\t},\r\n\t\t\tset(value) {\r\n\t\t\t\tObject.defineProperty(this, 'sizeTableBuffer', {\r\n\t\t\t\t\tvalue: value,\r\n\t\t\t\t\twritable: true,\r\n\t\t\t\t\tenumerable: true\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tconfigurable: true,\r\n\t\t}\r\n\t})\r\n\tif (isArray) {\r\n\t\tObject.define\r\n\t}\r\n\treturn new Proxy(target, copyOnWriteHandler)\r\n}\r\nexports.copy = copy\r\n\r\nvar specialSetters = {\r\n}\r\n/*specialSetters[sharedSymbol] = function(shared) {\r\n\treturn this.shared = shared\r\n}*/\r\n\r\nfunction getParsed(target) {\r\n\tvar parsed = target.parsed\r\n\tif (parsed)\r\n\t\treturn parsed\r\n\t// we check to see if there are multiple blocks that should be deferred into separate blocks\r\n\tvar sizeTableBuffer = target.sizeTableBuffer\r\n\tvar dpackBuffer = target.dpackBuffer\r\n\tif (!sizeTableBuffer) {\r\n\t\t// no child blocks, just dpack, so directly parse\r\n\t\treturn target.parsed = parse(dpackBuffer, {\r\n\t\t\tfreezeObjects: freezeObjects,\r\n\t\t\tshared: target.shared\r\n\t\t})\r\n\t}\r\n\tvar totalSizeTableLength = sizeTableBuffer.length\r\n\tvar totalDPackLength\r\n\tvar rootBlockLength\r\n\tvar type = sizeTableBuffer[0] >> 6\r\n\tvar offset\r\n\tif (type === 2) {\r\n\t\trootBlockLength = sizeTableBuffer.readUInt16BE(4)\r\n\t\toffset = 6\r\n\t} else {\r\n\t\trootBlockLength = sizeTableBuffer.readUIntBE(10, 6)\r\n\t\toffset = 16\r\n\t}\r\n\t// read child block lengths: (could defer this until child access)\r\n\tvar childSizeTables = []\r\n\tvar childDpackBlocks = []\r\n\tvar dpackChildOffset = rootBlockLength\r\n\twhile (offset < totalSizeTableLength) {\r\n\t\tvar type = sizeTableBuffer[offset] >> 6\r\n\t\tvar sizeTableLength\r\n\t\tvar dpackLength\r\n\t\tif (type < 2) { // leaf node\r\n\t\t\tif (type == 0) {\r\n\t\t\t\t// 6 bit\r\n\t\t\t\tsizeTableLength = 1\r\n\t\t\t\tdpackLength = sizeTableBuffer[offset]\r\n\t\t\t} else {\r\n\t\t\t\t// 14 bit\r\n\t\t\t\tsizeTableLength = 2\r\n\t\t\t\tdpackLength = sizeTableBuffer.readUInt16BE(offset) & 0x3fff\r\n\t\t\t}\r\n\t\t} else if (type === 2) {\r\n\t\t\tsizeTableLength = sizeTableBuffer.readUInt16BE(offset) & 0x3fff\r\n\t\t\tdpackLength = sizeTableBuffer.readUInt16BE(offset + 2)\r\n\t\t} else {\r\n\t\t\tsizeTableLength = sizeTableBuffer.readUInt32BE(offset) & 0x3fffffff\r\n\t\t\tdpackLength = sizeTableBuffer.readUIntBE(offset + 4, 6)\r\n\t\t}\r\n\t\tchildSizeTables.push(type < 2 ||\r\n\t\t\t(type == 3 && sizeTableLength == 16) ? // type 3 with a length of 16 is a long leaf node\r\n\t\t\tundefined : sizeTableBuffer.slice(offset, offset + sizeTableLength))\r\n\t\toffset += sizeTableLength\r\n\t\tchildDpackBlocks.push(dpackBuffer.slice(dpackChildOffset, dpackChildOffset += dpackLength))\r\n\t}\r\n\tvar blockIndex = 0\r\n\tvar rootBlock = target.dpackBuffer.slice(0, rootBlockLength)\r\n\treturn target.parsed = parse(rootBlock, childDpackBlocks.length > 0 ? { // if no child blocks, use normal deferred parsing\r\n\t\tshared: target.shared,\r\n\t\tforDeferred: function(value, property) {\r\n\t\t\tlet target = new value.constructor\r\n\t\t\ttarget.dpackBuffer = childDpackBlocks[blockIndex]\r\n\t\t\ttarget.sizeTableBuffer = childSizeTables[blockIndex++]\r\n\t\t\ttarget.shared = property ?\r\n\t\t\t\t\tproperty.upgrade ?\r\n\t\t\t\t\t\tproperty :\r\n\t\t\t\t\t\t{ code: property.code, key: null, type: property.type } :\r\n\t\t\t\t\tnull\r\n\t\t\treturn new Proxy(target, onDemandHandler)\r\n\t\t},\r\n\t\tfreezeObjects: freezeObjects\r\n\t} : {\r\n\t\tshared: target.shared\r\n\t})\r\n}\r\n\r\nfunction getSerialized(target, shareProperty) {\r\n\tvar childBlocks = []\r\n\tvar childSizeTables = []\r\n\tvar childDpackSizes = 0\r\n\tvar mustSequence // mustSequence is an indication that the blocks must be read in sequence and can't be randomly accessed\r\n\tvar serializerOptions = {\r\n\t\tforBlock: function(block, property) {\r\n\t\t\tvar dpackBuffer = block[bufferSymbol](property, true)\r\n\t\t\tif (dpackBuffer.mustSequence) {\r\n\t\t\t\tmustSequence = true\r\n\t\t\t\tchildBlocks.push(dpackBuffer)\r\n\t\t\t\treturn dpackBuffer\r\n\t\t\t}\r\n\t\t\tvar sizeTableBuffer = block[sizeTableSymbol]\r\n\t\t\tif (!sizeTableBuffer) {\r\n\t\t\t\t// if this child has no children, it won't have have size table, just create a leaf branch buffer\r\n\t\t\t\tvar bufferLength = dpackBuffer.length\r\n\t\t\t\tif (bufferLength < 64) {\r\n\t\t\t\t\t// one byte leaf node\r\n\t\t\t\t\tsizeTableBuffer = Buffer.from([bufferLength])\r\n\t\t\t\t} else if (bufferLength < 0x4000) {\r\n\t\t\t\t\t// binary-10 and then 14 bits\r\n\t\t\t\t\tsizeTableBuffer = Buffer.from([(bufferLength >> 8) | 0x40, bufferLength & 0xff])\r\n\t\t\t\t} else {\r\n\t\t\t\t\tsizeTableBuffer = Buffer.allocUnsafe(16)\r\n\t\t\t\t\tsizeTableBuffer.writeUInt32BE(0xc0000010) // binary-11 and then indicate a size of 16\r\n\t\t\t\t\tsizeTableBuffer.writeUIntBE(bufferLength, 4, 6)\r\n\t\t\t\t\tsizeTableBuffer.writeUIntBE(bufferLength, 10, 6)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tchildSizeTables.push(sizeTableBuffer)\r\n\t\t\tchildDpackSizes += dpackBuffer.length\r\n\t\t\tchildBlocks.push(dpackBuffer)\r\n\t\t\treturn dpackBuffer\r\n\t\t},\r\n\t\tshared: shareProperty,\r\n\t\tfreezeObjects: freezeObjects\r\n\t}\r\n\tvar rootBlock = serialize(target.parsed, serializerOptions)\r\n\tif (childBlocks.length == 0) {\r\n\t\t// no child blocks, just use the root block\r\n\t\treturn target.dpackBuffer = rootBlock\r\n\t}\r\n\tchildBlocks.unshift(rootBlock)\r\n\t// TODO: Do word aligment with any buffer copying, to make sure CPU can copy words instead of bytes\r\n\tvar dpackBuffer = target.dpackBuffer = Buffer.concat(childBlocks)\r\n\tif (mustSequence) {\r\n\t\treturn dpackBuffer\r\n\t}\r\n\tvar ourSizeBlock = Buffer.allocUnsafe(dpackBuffer.length >= 0x10000 ? 16 : 6)\r\n\tchildSizeTables.unshift(ourSizeBlock)\r\n\t// TODO: Add length parameter to concat so it is length % 8 = 0\r\n\tourSizeBlock = target.sizeTableBuffer = Buffer.concat(childSizeTables)\r\n\tif (dpackBuffer.length >= 0x10000) { // || ourSizeBlock.length > 0x4000\r\n\t\tourSizeBlock.writeUInt32BE(ourSizeBlock.length + 0xc0000000, 0) // binary-11 and then 30 bits\r\n\t\tourSizeBlock.writeUIntBE(dpackBuffer.length, 4, 6) // 48 bits\r\n\t\tourSizeBlock.writeUIntBE(rootBlock.length, 10, 6) // 48 bits\r\n\t} else {\r\n\t\tourSizeBlock.writeUInt16BE(ourSizeBlock.length | 0x8000, 0) // binary-10 and then 14 bits\r\n\t\tourSizeBlock.writeUInt16BE(dpackBuffer.length, 2) // 16 bits\r\n\t\tourSizeBlock.writeUInt16BE(rootBlock.length, 4) // 16 bits\r\n\r\n\t}\r\n\treturn dpackBuffer\r\n}\r\n\r\nfunction deepCopy(source) {\r\n\tlet target = new source.constructor()\r\n\tfor (let key in source) {\r\n\t\tlet value = source[key]\r\n\t\tif (value && typeof value == 'object')\r\n\t\t\tvalue = deepCopy(value)\r\n\t\ttarget[key] = value\r\n\t}\r\n\treturn target\r\n}\r\nvar parse = require('./parse').parse\r\nvar serializeSharedBlock = require('./shared').serializeSharedBlock\r\n\r\nexports.parseLazy = function(buffer, options) {\r\n\tif ((buffer[0] & 0x80) || // starts with size table\r\n\t\t(buffer[0] >> 4 === 3) || // sequence (object)\r\n\t\t(buffer[0] === 0x77)) { // array type\r\n\t\treturn makeBlockFromBuffer(buffer, options && options.shared)\r\n\t} else {\r\n\t\treturn parse(buffer, options)\r\n\t}\r\n}\r\n", "/*\r\nDPack - Fast, compact object structure encoding.\r\n*/\r\n\r\nexports.createSerializeStream = require('./lib/serialize-stream').createSerializeStream\r\nexports.createParseStream = require('./lib/parse-stream').createParseStream\r\nconst serialize = require('./lib/serialize')\r\nserialize.nodeCharEncoder = require('./lib/node-encoder').nodeCharEncoder\r\nconst parse = require('./lib/parse')\r\nconst Options = require('./lib/Options').Options\r\n\r\nexports.serialize = serialize.serialize\r\nexports.parse = parse.parse\r\nexports.createSerializer = serialize.createSerializer\r\nexports.createParser = parse.createParser\r\nconst Block = require('./lib/Block')\r\nexports.parseLazy = Block.parseLazy\r\nexports.asBlock = Block.asBlock\r\nexports.isBlock = Block.isBlock\r\nexports.copy = Block.copy\r\nexports.reassignBuffers = Block.reassignBuffers\r\nexports.Options = Options\r\nexports.createSharedStructure = require('./lib/shared').createSharedStructure\r\nexports.readSharedStructure = require('./lib/shared').readSharedStructure\r\n", "export function utf8Count(str: string): number {\n  const strLength = str.length;\n\n  let byteLength = 0;\n  let pos = 0;\n  while (pos < strLength) {\n    let value = str.charCodeAt(pos++);\n\n    if ((value & 0xffffff80) === 0) {\n      // 1-byte\n      byteLength++;\n      continue;\n    } else if ((value & 0xfffff800) === 0) {\n      // 2-bytes\n      byteLength += 2;\n    } else {\n      // handle surrogate pair\n      if (value >= 0xd800 && value <= 0xdbff) {\n        // high surrogate\n        if (pos < strLength) {\n          const extra = str.charCodeAt(pos);\n          if ((extra & 0xfc00) === 0xdc00) {\n            ++pos;\n            value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n          }\n        }\n      }\n\n      if ((value & 0xffff0000) === 0) {\n        // 3-byte\n        byteLength += 3;\n      } else {\n        // 4-byte\n        byteLength += 4;\n      }\n    }\n  }\n  return byteLength;\n}\n\nexport function utf8EncodeJs(str: string, output: Uint8Array, outputOffset: number): void {\n  const strLength = str.length;\n  let offset = outputOffset;\n  let pos = 0;\n  while (pos < strLength) {\n    let value = str.charCodeAt(pos++);\n\n    if ((value & 0xffffff80) === 0) {\n      // 1-byte\n      output[offset++] = value;\n      continue;\n    } else if ((value & 0xfffff800) === 0) {\n      // 2-bytes\n      output[offset++] = ((value >> 6) & 0x1f) | 0xc0;\n    } else {\n      // handle surrogate pair\n      if (value >= 0xd800 && value <= 0xdbff) {\n        // high surrogate\n        if (pos < strLength) {\n          const extra = str.charCodeAt(pos);\n          if ((extra & 0xfc00) === 0xdc00) {\n            ++pos;\n            value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n          }\n        }\n      }\n\n      if ((value & 0xffff0000) === 0) {\n        // 3-byte\n        output[offset++] = ((value >> 12) & 0x0f) | 0xe0;\n        output[offset++] = ((value >> 6) & 0x3f) | 0x80;\n      } else {\n        // 4-byte\n        output[offset++] = ((value >> 18) & 0x07) | 0xf0;\n        output[offset++] = ((value >> 12) & 0x3f) | 0x80;\n        output[offset++] = ((value >> 6) & 0x3f) | 0x80;\n      }\n    }\n\n    output[offset++] = (value & 0x3f) | 0x80;\n  }\n}\n\n// TextEncoder and TextDecoder are standardized in whatwg encoding:\n// https://encoding.spec.whatwg.org/\n// and available in all the modern browsers:\n// https://caniuse.com/textencoder\n// They are available in Node.js since v12 LTS as well:\n// https://nodejs.org/api/globals.html#textencoder\n\nconst sharedTextEncoder = new TextEncoder();\n\n// This threshold should be determined by benchmarking, which might vary in engines and input data.\n// Run `npx ts-node benchmark/encode-string.ts` for details.\nconst TEXT_ENCODER_THRESHOLD = 50;\n\nexport function utf8EncodeTE(str: string, output: Uint8Array, outputOffset: number): void {\n  sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));\n}\n\nexport function utf8Encode(str: string, output: Uint8Array, outputOffset: number): void {\n  if (str.length > TEXT_ENCODER_THRESHOLD) {\n    utf8EncodeTE(str, output, outputOffset);\n  } else {\n    utf8EncodeJs(str, output, outputOffset);\n  }\n}\n\nconst CHUNK_SIZE = 0x1_000;\n\nexport function utf8DecodeJs(bytes: Uint8Array, inputOffset: number, byteLength: number): string {\n  let offset = inputOffset;\n  const end = offset + byteLength;\n\n  const units: Array<number> = [];\n  let result = \"\";\n  while (offset < end) {\n    const byte1 = bytes[offset++]!;\n    if ((byte1 & 0x80) === 0) {\n      // 1 byte\n      units.push(byte1);\n    } else if ((byte1 & 0xe0) === 0xc0) {\n      // 2 bytes\n      const byte2 = bytes[offset++]! & 0x3f;\n      units.push(((byte1 & 0x1f) << 6) | byte2);\n    } else if ((byte1 & 0xf0) === 0xe0) {\n      // 3 bytes\n      const byte2 = bytes[offset++]! & 0x3f;\n      const byte3 = bytes[offset++]! & 0x3f;\n      units.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3);\n    } else if ((byte1 & 0xf8) === 0xf0) {\n      // 4 bytes\n      const byte2 = bytes[offset++]! & 0x3f;\n      const byte3 = bytes[offset++]! & 0x3f;\n      const byte4 = bytes[offset++]! & 0x3f;\n      let unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4;\n      if (unit > 0xffff) {\n        unit -= 0x10000;\n        units.push(((unit >>> 10) & 0x3ff) | 0xd800);\n        unit = 0xdc00 | (unit & 0x3ff);\n      }\n      units.push(unit);\n    } else {\n      units.push(byte1);\n    }\n\n    if (units.length >= CHUNK_SIZE) {\n      result += String.fromCharCode(...units);\n      units.length = 0;\n    }\n  }\n\n  if (units.length > 0) {\n    result += String.fromCharCode(...units);\n  }\n\n  return result;\n}\n\nconst sharedTextDecoder = new TextDecoder();\n\n// This threshold should be determined by benchmarking, which might vary in engines and input data.\n// Run `npx ts-node benchmark/decode-string.ts` for details.\nconst TEXT_DECODER_THRESHOLD = 200;\n\nexport function utf8DecodeTD(bytes: Uint8Array, inputOffset: number, byteLength: number): string {\n  const stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);\n  return sharedTextDecoder.decode(stringBytes);\n}\n\nexport function utf8Decode(bytes: Uint8Array, inputOffset: number, byteLength: number): string {\n  if (byteLength > TEXT_DECODER_THRESHOLD) {\n    return utf8DecodeTD(bytes, inputOffset, byteLength);\n  } else {\n    return utf8DecodeJs(bytes, inputOffset, byteLength);\n  }\n}\n", "/**\n * ExtData is used to handle Extension Types that are not registered to ExtensionCodec.\n */\nexport class ExtData {\n  readonly type: number;\n  readonly data: Uint8Array | ((pos: number) => Uint8Array);\n\n  constructor(type: number, data: Uint8Array | ((pos: number) => Uint8Array)) {\n    this.type = type;\n    this.data = data;\n  }\n}\n", "export class DecodeError extends Error {\n  constructor(message: string) {\n    super(message);\n\n    // fix the prototype chain in a cross-platform way\n    const proto: typeof DecodeError.prototype = Object.create(DecodeError.prototype);\n    Object.setPrototypeOf(this, proto);\n\n    Object.defineProperty(this, \"name\", {\n      configurable: true,\n      enumerable: false,\n      value: DecodeError.name,\n    });\n  }\n}\n", "// Integer Utility\n\nexport const UINT32_MAX = 0xffff_ffff;\n\n// DataView extension to handle int64 / uint64,\n// where the actual range is 53-bits integer (a.k.a. safe integer)\n\nexport function setUint64(view: DataView, offset: number, value: number): void {\n  const high = value / 0x1_0000_0000;\n  const low = value; // high bits are truncated by DataView\n  view.setUint32(offset, high);\n  view.setUint32(offset + 4, low);\n}\n\nexport function setInt64(view: DataView, offset: number, value: number): void {\n  const high = Math.floor(value / 0x1_0000_0000);\n  const low = value; // high bits are truncated by DataView\n  view.setUint32(offset, high);\n  view.setUint32(offset + 4, low);\n}\n\nexport function getInt64(view: DataView, offset: number): number {\n  const high = view.getInt32(offset);\n  const low = view.getUint32(offset + 4);\n  return high * 0x1_0000_0000 + low;\n}\n\nexport function getUint64(view: DataView, offset: number): number {\n  const high = view.getUint32(offset);\n  const low = view.getUint32(offset + 4);\n  return high * 0x1_0000_0000 + low;\n}\n", "// https://github.com/msgpack/msgpack/blob/master/spec.md#timestamp-extension-type\nimport { DecodeError } from \"./DecodeError.ts\";\nimport { getInt64, setInt64 } from \"./utils/int.ts\";\n\nexport const EXT_TIMESTAMP = -1;\n\nexport type TimeSpec = {\n  sec: number;\n  nsec: number;\n};\n\nconst TIMESTAMP32_MAX_SEC = 0x100000000 - 1; // 32-bit unsigned int\nconst TIMESTAMP64_MAX_SEC = 0x400000000 - 1; // 34-bit unsigned int\n\nexport function encodeTimeSpecToTimestamp({ sec, nsec }: TimeSpec): Uint8Array {\n  if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {\n    // Here sec >= 0 && nsec >= 0\n    if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {\n      // timestamp 32 = { sec32 (unsigned) }\n      const rv = new Uint8Array(4);\n      const view = new DataView(rv.buffer);\n      view.setUint32(0, sec);\n      return rv;\n    } else {\n      // timestamp 64 = { nsec30 (unsigned), sec34 (unsigned) }\n      const secHigh = sec / 0x100000000;\n      const secLow = sec & 0xffffffff;\n      const rv = new Uint8Array(8);\n      const view = new DataView(rv.buffer);\n      // nsec30 | secHigh2\n      view.setUint32(0, (nsec << 2) | (secHigh & 0x3));\n      // secLow32\n      view.setUint32(4, secLow);\n      return rv;\n    }\n  } else {\n    // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }\n    const rv = new Uint8Array(12);\n    const view = new DataView(rv.buffer);\n    view.setUint32(0, nsec);\n    setInt64(view, 4, sec);\n    return rv;\n  }\n}\n\nexport function encodeDateToTimeSpec(date: Date): TimeSpec {\n  const msec = date.getTime();\n  const sec = Math.floor(msec / 1e3);\n  const nsec = (msec - sec * 1e3) * 1e6;\n\n  // Normalizes { sec, nsec } to ensure nsec is unsigned.\n  const nsecInSec = Math.floor(nsec / 1e9);\n  return {\n    sec: sec + nsecInSec,\n    nsec: nsec - nsecInSec * 1e9,\n  };\n}\n\nexport function encodeTimestampExtension(object: unknown): Uint8Array | null {\n  if (object instanceof Date) {\n    const timeSpec = encodeDateToTimeSpec(object);\n    return encodeTimeSpecToTimestamp(timeSpec);\n  } else {\n    return null;\n  }\n}\n\nexport function decodeTimestampToTimeSpec(data: Uint8Array): TimeSpec {\n  const view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n\n  // data may be 32, 64, or 96 bits\n  switch (data.byteLength) {\n    case 4: {\n      // timestamp 32 = { sec32 }\n      const sec = view.getUint32(0);\n      const nsec = 0;\n      return { sec, nsec };\n    }\n    case 8: {\n      // timestamp 64 = { nsec30, sec34 }\n      const nsec30AndSecHigh2 = view.getUint32(0);\n      const secLow32 = view.getUint32(4);\n      const sec = (nsec30AndSecHigh2 & 0x3) * 0x100000000 + secLow32;\n      const nsec = nsec30AndSecHigh2 >>> 2;\n      return { sec, nsec };\n    }\n    case 12: {\n      // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }\n\n      const sec = getInt64(view, 4);\n      const nsec = view.getUint32(0);\n      return { sec, nsec };\n    }\n    default:\n      throw new DecodeError(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${data.length}`);\n  }\n}\n\nexport function decodeTimestampExtension(data: Uint8Array): Date {\n  const timeSpec = decodeTimestampToTimeSpec(data);\n  return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);\n}\n\nexport const timestampExtension = {\n  type: EXT_TIMESTAMP,\n  encode: encodeTimestampExtension,\n  decode: decodeTimestampExtension,\n};\n", "// ExtensionCodec to handle MessagePack extensions\n\nimport { ExtData } from \"./ExtData.ts\";\nimport { timestampExtension } from \"./timestamp.ts\";\n\nexport type ExtensionDecoderType<ContextType> = (\n  data: Uint8Array,\n  extensionType: number,\n  context: ContextType,\n) => unknown;\n\nexport type ExtensionEncoderType<ContextType> = (\n  input: unknown,\n  context: ContextType,\n) => Uint8Array | ((dataPos: number) => Uint8Array) | null;\n\n// immutable interface to ExtensionCodec\nexport type ExtensionCodecType<ContextType> = {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  __brand?: ContextType;\n  tryToEncode(object: unknown, context: ContextType): ExtData | null;\n  decode(data: Uint8Array, extType: number, context: ContextType): unknown;\n};\n\nexport class ExtensionCodec<ContextType = undefined> implements ExtensionCodecType<ContextType> {\n  public static readonly defaultCodec: ExtensionCodecType<undefined> = new ExtensionCodec();\n\n  // ensures ExtensionCodecType<X> matches ExtensionCodec<X>\n  // this will make type errors a lot more clear\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  __brand?: ContextType;\n\n  // built-in extensions\n  private readonly builtInEncoders: Array<ExtensionEncoderType<ContextType> | undefined | null> = [];\n  private readonly builtInDecoders: Array<ExtensionDecoderType<ContextType> | undefined | null> = [];\n\n  // custom extensions\n  private readonly encoders: Array<ExtensionEncoderType<ContextType> | undefined | null> = [];\n  private readonly decoders: Array<ExtensionDecoderType<ContextType> | undefined | null> = [];\n\n  public constructor() {\n    this.register(timestampExtension);\n  }\n\n  public register({\n    type,\n    encode,\n    decode,\n  }: {\n    type: number;\n    encode: ExtensionEncoderType<ContextType>;\n    decode: ExtensionDecoderType<ContextType>;\n  }): void {\n    if (type >= 0) {\n      // custom extensions\n      this.encoders[type] = encode;\n      this.decoders[type] = decode;\n    } else {\n      // built-in extensions\n      const index = -1 - type;\n      this.builtInEncoders[index] = encode;\n      this.builtInDecoders[index] = decode;\n    }\n  }\n\n  public tryToEncode(object: unknown, context: ContextType): ExtData | null {\n    // built-in extensions\n    for (let i = 0; i < this.builtInEncoders.length; i++) {\n      const encodeExt = this.builtInEncoders[i];\n      if (encodeExt != null) {\n        const data = encodeExt(object, context);\n        if (data != null) {\n          const type = -1 - i;\n          return new ExtData(type, data);\n        }\n      }\n    }\n\n    // custom extensions\n    for (let i = 0; i < this.encoders.length; i++) {\n      const encodeExt = this.encoders[i];\n      if (encodeExt != null) {\n        const data = encodeExt(object, context);\n        if (data != null) {\n          const type = i;\n          return new ExtData(type, data);\n        }\n      }\n    }\n\n    if (object instanceof ExtData) {\n      // to keep ExtData as is\n      return object;\n    }\n    return null;\n  }\n\n  public decode(data: Uint8Array, type: number, context: ContextType): unknown {\n    const decodeExt = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type];\n    if (decodeExt) {\n      return decodeExt(data, type, context);\n    } else {\n      // decode() does not fail, returns ExtData instead.\n      return new ExtData(type, data);\n    }\n  }\n}\n", "function isArrayBufferLike(buffer: unknown): buffer is ArrayBufferLike {\n  return (\n    buffer instanceof ArrayBuffer || (typeof SharedArrayBuffer !== \"undefined\" && buffer instanceof SharedArrayBuffer)\n  );\n}\n\nexport function ensureUint8Array(\n  buffer: ArrayLike<number> | Uint8Array<ArrayBufferLike> | ArrayBufferView | ArrayBufferLike,\n): Uint8Array<ArrayBufferLike> {\n  if (buffer instanceof Uint8Array) {\n    return buffer;\n  } else if (ArrayBuffer.isView(buffer)) {\n    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n  } else if (isArrayBufferLike(buffer)) {\n    return new Uint8Array(buffer);\n  } else {\n    // ArrayLike<number>\n    return Uint8Array.from(buffer);\n  }\n}\n", "import { utf8Count, utf8Encode } from \"./utils/utf8.ts\";\nimport { ExtensionCodec } from \"./ExtensionCodec.ts\";\nimport { setInt64, setUint64 } from \"./utils/int.ts\";\nimport { ensureUint8Array } from \"./utils/typedArrays.ts\";\nimport type { ExtData } from \"./ExtData.ts\";\nimport type { ContextOf } from \"./context.ts\";\nimport type { ExtensionCodecType } from \"./ExtensionCodec.ts\";\n\nexport const DEFAULT_MAX_DEPTH = 100;\nexport const DEFAULT_INITIAL_BUFFER_SIZE = 2048;\n\nexport type EncoderOptions<ContextType = undefined> = Partial<\n  Readonly<{\n    extensionCodec: ExtensionCodecType<ContextType>;\n\n    /**\n     * Encodes bigint as Int64 or Uint64 if it's set to true.\n     * {@link forceIntegerToFloat} does not affect bigint.\n     * Depends on ES2020's {@link DataView#setBigInt64} and\n     * {@link DataView#setBigUint64}.\n     *\n     * Defaults to false.\n     */\n    useBigInt64: boolean;\n\n    /**\n     * The maximum depth in nested objects and arrays.\n     *\n     * Defaults to 100.\n     */\n    maxDepth: number;\n\n    /**\n     * The initial size of the internal buffer.\n     *\n     * Defaults to 2048.\n     */\n    initialBufferSize: number;\n\n    /**\n     * If `true`, the keys of an object is sorted. In other words, the encoded\n     * binary is canonical and thus comparable to another encoded binary.\n     *\n     * Defaults to `false`. If enabled, it spends more time in encoding objects.\n     */\n    sortKeys: boolean;\n    /**\n     * If `true`, non-integer numbers are encoded in float32, not in float64 (the default).\n     *\n     * Only use it if precisions don't matter.\n     *\n     * Defaults to `false`.\n     */\n    forceFloat32: boolean;\n\n    /**\n     * If `true`, an object property with `undefined` value are ignored.\n     * e.g. `{ foo: undefined }` will be encoded as `{}`, as `JSON.stringify()` does.\n     *\n     * Defaults to `false`. If enabled, it spends more time in encoding objects.\n     */\n    ignoreUndefined: boolean;\n\n    /**\n     * If `true`, integer numbers are encoded as floating point numbers,\n     * with the `forceFloat32` option taken into account.\n     *\n     * Defaults to `false`.\n     */\n    forceIntegerToFloat: boolean;\n  }>\n> &\n  ContextOf<ContextType>;\n\nexport class Encoder<ContextType = undefined> {\n  private readonly extensionCodec: ExtensionCodecType<ContextType>;\n  private readonly context: ContextType;\n  private readonly useBigInt64: boolean;\n  private readonly maxDepth: number;\n  private readonly initialBufferSize: number;\n  private readonly sortKeys: boolean;\n  private readonly forceFloat32: boolean;\n  private readonly ignoreUndefined: boolean;\n  private readonly forceIntegerToFloat: boolean;\n\n  private pos: number;\n  private view: DataView<ArrayBuffer>;\n  private bytes: Uint8Array<ArrayBuffer>;\n\n  private entered = false;\n\n  public constructor(options?: EncoderOptions<ContextType>) {\n    this.extensionCodec = options?.extensionCodec ?? (ExtensionCodec.defaultCodec as ExtensionCodecType<ContextType>);\n    this.context = (options as { context: ContextType } | undefined)?.context as ContextType; // needs a type assertion because EncoderOptions has no context property when ContextType is undefined\n\n    this.useBigInt64 = options?.useBigInt64 ?? false;\n    this.maxDepth = options?.maxDepth ?? DEFAULT_MAX_DEPTH;\n    this.initialBufferSize = options?.initialBufferSize ?? DEFAULT_INITIAL_BUFFER_SIZE;\n    this.sortKeys = options?.sortKeys ?? false;\n    this.forceFloat32 = options?.forceFloat32 ?? false;\n    this.ignoreUndefined = options?.ignoreUndefined ?? false;\n    this.forceIntegerToFloat = options?.forceIntegerToFloat ?? false;\n\n    this.pos = 0;\n    this.view = new DataView(new ArrayBuffer(this.initialBufferSize));\n    this.bytes = new Uint8Array(this.view.buffer);\n  }\n\n  private clone() {\n    // Because of slightly special argument `context`,\n    // type assertion is needed.\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n    return new Encoder<ContextType>({\n      extensionCodec: this.extensionCodec,\n      context: this.context,\n      useBigInt64: this.useBigInt64,\n      maxDepth: this.maxDepth,\n      initialBufferSize: this.initialBufferSize,\n      sortKeys: this.sortKeys,\n      forceFloat32: this.forceFloat32,\n      ignoreUndefined: this.ignoreUndefined,\n      forceIntegerToFloat: this.forceIntegerToFloat,\n    } as any);\n  }\n\n  private reinitializeState() {\n    this.pos = 0;\n  }\n\n  /**\n   * This is almost equivalent to {@link Encoder#encode}, but it returns an reference of the encoder's internal buffer and thus much faster than {@link Encoder#encode}.\n   *\n   * @returns Encodes the object and returns a shared reference the encoder's internal buffer.\n   */\n  public encodeSharedRef(object: unknown): Uint8Array<ArrayBuffer> {\n    if (this.entered) {\n      const instance = this.clone();\n      return instance.encodeSharedRef(object);\n    }\n\n    try {\n      this.entered = true;\n\n      this.reinitializeState();\n      this.doEncode(object, 1);\n      return this.bytes.subarray(0, this.pos);\n    } finally {\n      this.entered = false;\n    }\n  }\n\n  /**\n   * @returns Encodes the object and returns a copy of the encoder's internal buffer.\n   */\n  public encode(object: unknown): Uint8Array<ArrayBuffer> {\n    if (this.entered) {\n      const instance = this.clone();\n      return instance.encode(object);\n    }\n\n    try {\n      this.entered = true;\n\n      this.reinitializeState();\n      this.doEncode(object, 1);\n      return this.bytes.slice(0, this.pos);\n    } finally {\n      this.entered = false;\n    }\n  }\n\n  private doEncode(object: unknown, depth: number): void {\n    if (depth > this.maxDepth) {\n      throw new Error(`Too deep objects in depth ${depth}`);\n    }\n\n    if (object == null) {\n      this.encodeNil();\n    } else if (typeof object === \"boolean\") {\n      this.encodeBoolean(object);\n    } else if (typeof object === \"number\") {\n      if (!this.forceIntegerToFloat) {\n        this.encodeNumber(object);\n      } else {\n        this.encodeNumberAsFloat(object);\n      }\n    } else if (typeof object === \"string\") {\n      this.encodeString(object);\n    } else if (this.useBigInt64 && typeof object === \"bigint\") {\n      this.encodeBigInt64(object);\n    } else {\n      this.encodeObject(object, depth);\n    }\n  }\n\n  private ensureBufferSizeToWrite(sizeToWrite: number) {\n    const requiredSize = this.pos + sizeToWrite;\n\n    if (this.view.byteLength < requiredSize) {\n      this.resizeBuffer(requiredSize * 2);\n    }\n  }\n\n  private resizeBuffer(newSize: number) {\n    const newBuffer = new ArrayBuffer(newSize);\n    const newBytes = new Uint8Array(newBuffer);\n    const newView = new DataView(newBuffer);\n\n    newBytes.set(this.bytes);\n\n    this.view = newView;\n    this.bytes = newBytes;\n  }\n\n  private encodeNil() {\n    this.writeU8(0xc0);\n  }\n\n  private encodeBoolean(object: boolean) {\n    if (object === false) {\n      this.writeU8(0xc2);\n    } else {\n      this.writeU8(0xc3);\n    }\n  }\n\n  private encodeNumber(object: number): void {\n    if (!this.forceIntegerToFloat && Number.isSafeInteger(object)) {\n      if (object >= 0) {\n        if (object < 0x80) {\n          // positive fixint\n          this.writeU8(object);\n        } else if (object < 0x100) {\n          // uint 8\n          this.writeU8(0xcc);\n          this.writeU8(object);\n        } else if (object < 0x10000) {\n          // uint 16\n          this.writeU8(0xcd);\n          this.writeU16(object);\n        } else if (object < 0x100000000) {\n          // uint 32\n          this.writeU8(0xce);\n          this.writeU32(object);\n        } else if (!this.useBigInt64) {\n          // uint 64\n          this.writeU8(0xcf);\n          this.writeU64(object);\n        } else {\n          this.encodeNumberAsFloat(object);\n        }\n      } else {\n        if (object >= -0x20) {\n          // negative fixint\n          this.writeU8(0xe0 | (object + 0x20));\n        } else if (object >= -0x80) {\n          // int 8\n          this.writeU8(0xd0);\n          this.writeI8(object);\n        } else if (object >= -0x8000) {\n          // int 16\n          this.writeU8(0xd1);\n          this.writeI16(object);\n        } else if (object >= -0x80000000) {\n          // int 32\n          this.writeU8(0xd2);\n          this.writeI32(object);\n        } else if (!this.useBigInt64) {\n          // int 64\n          this.writeU8(0xd3);\n          this.writeI64(object);\n        } else {\n          this.encodeNumberAsFloat(object);\n        }\n      }\n    } else {\n      this.encodeNumberAsFloat(object);\n    }\n  }\n\n  private encodeNumberAsFloat(object: number): void {\n    if (this.forceFloat32) {\n      // float 32\n      this.writeU8(0xca);\n      this.writeF32(object);\n    } else {\n      // float 64\n      this.writeU8(0xcb);\n      this.writeF64(object);\n    }\n  }\n\n  private encodeBigInt64(object: bigint): void {\n    if (object >= BigInt(0)) {\n      // uint 64\n      this.writeU8(0xcf);\n      this.writeBigUint64(object);\n    } else {\n      // int 64\n      this.writeU8(0xd3);\n      this.writeBigInt64(object);\n    }\n  }\n\n  private writeStringHeader(byteLength: number) {\n    if (byteLength < 32) {\n      // fixstr\n      this.writeU8(0xa0 + byteLength);\n    } else if (byteLength < 0x100) {\n      // str 8\n      this.writeU8(0xd9);\n      this.writeU8(byteLength);\n    } else if (byteLength < 0x10000) {\n      // str 16\n      this.writeU8(0xda);\n      this.writeU16(byteLength);\n    } else if (byteLength < 0x100000000) {\n      // str 32\n      this.writeU8(0xdb);\n      this.writeU32(byteLength);\n    } else {\n      throw new Error(`Too long string: ${byteLength} bytes in UTF-8`);\n    }\n  }\n\n  private encodeString(object: string) {\n    const maxHeaderSize = 1 + 4;\n\n    const byteLength = utf8Count(object);\n    this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n    this.writeStringHeader(byteLength);\n    utf8Encode(object, this.bytes, this.pos);\n    this.pos += byteLength;\n  }\n\n  private encodeObject(object: unknown, depth: number) {\n    // try to encode objects with custom codec first of non-primitives\n    const ext = this.extensionCodec.tryToEncode(object, this.context);\n    if (ext != null) {\n      this.encodeExtension(ext);\n    } else if (Array.isArray(object)) {\n      this.encodeArray(object, depth);\n    } else if (ArrayBuffer.isView(object)) {\n      this.encodeBinary(object);\n    } else if (typeof object === \"object\") {\n      this.encodeMap(object as Record<string, unknown>, depth);\n    } else {\n      // symbol, function and other special object come here unless extensionCodec handles them.\n      throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(object)}`);\n    }\n  }\n\n  private encodeBinary(object: ArrayBufferView) {\n    const size = object.byteLength;\n    if (size < 0x100) {\n      // bin 8\n      this.writeU8(0xc4);\n      this.writeU8(size);\n    } else if (size < 0x10000) {\n      // bin 16\n      this.writeU8(0xc5);\n      this.writeU16(size);\n    } else if (size < 0x100000000) {\n      // bin 32\n      this.writeU8(0xc6);\n      this.writeU32(size);\n    } else {\n      throw new Error(`Too large binary: ${size}`);\n    }\n    const bytes = ensureUint8Array(object);\n    this.writeU8a(bytes);\n  }\n\n  private encodeArray(object: Array<unknown>, depth: number) {\n    const size = object.length;\n    if (size < 16) {\n      // fixarray\n      this.writeU8(0x90 + size);\n    } else if (size < 0x10000) {\n      // array 16\n      this.writeU8(0xdc);\n      this.writeU16(size);\n    } else if (size < 0x100000000) {\n      // array 32\n      this.writeU8(0xdd);\n      this.writeU32(size);\n    } else {\n      throw new Error(`Too large array: ${size}`);\n    }\n    for (const item of object) {\n      this.doEncode(item, depth + 1);\n    }\n  }\n\n  private countWithoutUndefined(object: Record<string, unknown>, keys: ReadonlyArray<string>): number {\n    let count = 0;\n\n    for (const key of keys) {\n      if (object[key] !== undefined) {\n        count++;\n      }\n    }\n\n    return count;\n  }\n\n  private encodeMap(object: Record<string, unknown>, depth: number) {\n    const keys = Object.keys(object);\n    if (this.sortKeys) {\n      keys.sort();\n    }\n\n    const size = this.ignoreUndefined ? this.countWithoutUndefined(object, keys) : keys.length;\n\n    if (size < 16) {\n      // fixmap\n      this.writeU8(0x80 + size);\n    } else if (size < 0x10000) {\n      // map 16\n      this.writeU8(0xde);\n      this.writeU16(size);\n    } else if (size < 0x100000000) {\n      // map 32\n      this.writeU8(0xdf);\n      this.writeU32(size);\n    } else {\n      throw new Error(`Too large map object: ${size}`);\n    }\n\n    for (const key of keys) {\n      const value = object[key];\n\n      if (!(this.ignoreUndefined && value === undefined)) {\n        this.encodeString(key);\n        this.doEncode(value, depth + 1);\n      }\n    }\n  }\n\n  private encodeExtension(ext: ExtData) {\n    if (typeof ext.data === \"function\") {\n      const data = ext.data(this.pos + 6);\n      const size = data.length;\n\n      if (size >= 0x100000000) {\n        throw new Error(`Too large extension object: ${size}`);\n      }\n\n      this.writeU8(0xc9);\n      this.writeU32(size);\n      this.writeI8(ext.type);\n      this.writeU8a(data);\n      return;\n    }\n\n    const size = ext.data.length;\n    if (size === 1) {\n      // fixext 1\n      this.writeU8(0xd4);\n    } else if (size === 2) {\n      // fixext 2\n      this.writeU8(0xd5);\n    } else if (size === 4) {\n      // fixext 4\n      this.writeU8(0xd6);\n    } else if (size === 8) {\n      // fixext 8\n      this.writeU8(0xd7);\n    } else if (size === 16) {\n      // fixext 16\n      this.writeU8(0xd8);\n    } else if (size < 0x100) {\n      // ext 8\n      this.writeU8(0xc7);\n      this.writeU8(size);\n    } else if (size < 0x10000) {\n      // ext 16\n      this.writeU8(0xc8);\n      this.writeU16(size);\n    } else if (size < 0x100000000) {\n      // ext 32\n      this.writeU8(0xc9);\n      this.writeU32(size);\n    } else {\n      throw new Error(`Too large extension object: ${size}`);\n    }\n    this.writeI8(ext.type);\n    this.writeU8a(ext.data);\n  }\n\n  private writeU8(value: number) {\n    this.ensureBufferSizeToWrite(1);\n\n    this.view.setUint8(this.pos, value);\n    this.pos++;\n  }\n\n  private writeU8a(values: ArrayLike<number>) {\n    const size = values.length;\n    this.ensureBufferSizeToWrite(size);\n\n    this.bytes.set(values, this.pos);\n    this.pos += size;\n  }\n\n  private writeI8(value: number) {\n    this.ensureBufferSizeToWrite(1);\n\n    this.view.setInt8(this.pos, value);\n    this.pos++;\n  }\n\n  private writeU16(value: number) {\n    this.ensureBufferSizeToWrite(2);\n\n    this.view.setUint16(this.pos, value);\n    this.pos += 2;\n  }\n\n  private writeI16(value: number) {\n    this.ensureBufferSizeToWrite(2);\n\n    this.view.setInt16(this.pos, value);\n    this.pos += 2;\n  }\n\n  private writeU32(value: number) {\n    this.ensureBufferSizeToWrite(4);\n\n    this.view.setUint32(this.pos, value);\n    this.pos += 4;\n  }\n\n  private writeI32(value: number) {\n    this.ensureBufferSizeToWrite(4);\n\n    this.view.setInt32(this.pos, value);\n    this.pos += 4;\n  }\n\n  private writeF32(value: number) {\n    this.ensureBufferSizeToWrite(4);\n\n    this.view.setFloat32(this.pos, value);\n    this.pos += 4;\n  }\n\n  private writeF64(value: number) {\n    this.ensureBufferSizeToWrite(8);\n\n    this.view.setFloat64(this.pos, value);\n    this.pos += 8;\n  }\n\n  private writeU64(value: number) {\n    this.ensureBufferSizeToWrite(8);\n\n    setUint64(this.view, this.pos, value);\n    this.pos += 8;\n  }\n\n  private writeI64(value: number) {\n    this.ensureBufferSizeToWrite(8);\n\n    setInt64(this.view, this.pos, value);\n    this.pos += 8;\n  }\n\n  private writeBigUint64(value: bigint) {\n    this.ensureBufferSizeToWrite(8);\n\n    this.view.setBigUint64(this.pos, value);\n    this.pos += 8;\n  }\n\n  private writeBigInt64(value: bigint) {\n    this.ensureBufferSizeToWrite(8);\n\n    this.view.setBigInt64(this.pos, value);\n    this.pos += 8;\n  }\n}\n", "import { Encoder } from \"./Encoder.ts\";\nimport type { EncoderOptions } from \"./Encoder.ts\";\nimport type { SplitUndefined } from \"./context.ts\";\n\n/**\n * It encodes `value` in the MessagePack format and\n * returns a byte buffer.\n *\n * The returned buffer is a slice of a larger `ArrayBuffer`, so you have to use its `#byteOffset` and `#byteLength` in order to convert it to another typed arrays including NodeJS `Buffer`.\n */\nexport function encode<ContextType = undefined>(\n  value: unknown,\n  options?: EncoderOptions<SplitUndefined<ContextType>>,\n): Uint8Array<ArrayBuffer> {\n  const encoder = new Encoder(options);\n  return encoder.encodeSharedRef(value);\n}\n", "export function prettyByte(byte: number): string {\n  return `${byte < 0 ? \"-\" : \"\"}0x${Math.abs(byte).toString(16).padStart(2, \"0\")}`;\n}\n", "import { utf8DecodeJs } from \"./utils/utf8.ts\";\n\nconst DEFAULT_MAX_KEY_LENGTH = 16;\nconst DEFAULT_MAX_LENGTH_PER_KEY = 16;\n\nexport interface KeyDecoder {\n  canBeCached(byteLength: number): boolean;\n  decode(bytes: Uint8Array, inputOffset: number, byteLength: number): string;\n}\ninterface KeyCacheRecord {\n  readonly bytes: Uint8Array;\n  readonly str: string;\n}\n\nexport class CachedKeyDecoder implements KeyDecoder {\n  hit = 0;\n  miss = 0;\n  private readonly caches: Array<Array<KeyCacheRecord>>;\n  readonly maxKeyLength: number;\n  readonly maxLengthPerKey: number;\n\n  constructor(maxKeyLength = DEFAULT_MAX_KEY_LENGTH, maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY) {\n    this.maxKeyLength = maxKeyLength;\n    this.maxLengthPerKey = maxLengthPerKey;\n\n    // avoid `new Array(N)`, which makes a sparse array,\n    // because a sparse array is typically slower than a non-sparse array.\n    this.caches = [];\n    for (let i = 0; i < this.maxKeyLength; i++) {\n      this.caches.push([]);\n    }\n  }\n\n  public canBeCached(byteLength: number): boolean {\n    return byteLength > 0 && byteLength <= this.maxKeyLength;\n  }\n\n  private find(bytes: Uint8Array, inputOffset: number, byteLength: number): string | null {\n    const records = this.caches[byteLength - 1]!;\n\n    FIND_CHUNK: for (const record of records) {\n      const recordBytes = record.bytes;\n\n      for (let j = 0; j < byteLength; j++) {\n        if (recordBytes[j] !== bytes[inputOffset + j]) {\n          continue FIND_CHUNK;\n        }\n      }\n      return record.str;\n    }\n    return null;\n  }\n\n  private store(bytes: Uint8Array, value: string) {\n    const records = this.caches[bytes.length - 1]!;\n    const record: KeyCacheRecord = { bytes, str: value };\n\n    if (records.length >= this.maxLengthPerKey) {\n      // `records` are full!\n      // Set `record` to an arbitrary position.\n      records[(Math.random() * records.length) | 0] = record;\n    } else {\n      records.push(record);\n    }\n  }\n\n  public decode(bytes: Uint8Array, inputOffset: number, byteLength: number): string {\n    const cachedValue = this.find(bytes, inputOffset, byteLength);\n    if (cachedValue != null) {\n      this.hit++;\n      return cachedValue;\n    }\n    this.miss++;\n\n    const str = utf8DecodeJs(bytes, inputOffset, byteLength);\n    // Ensure to copy a slice of bytes because the bytes may be a NodeJS Buffer and Buffer#slice() returns a reference to its internal ArrayBuffer.\n    const slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);\n    this.store(slicedCopyOfBytes, str);\n    return str;\n  }\n}\n", "import { prettyByte } from \"./utils/prettyByte.ts\";\nimport { ExtensionCodec } from \"./ExtensionCodec.ts\";\nimport { getInt64, getUint64, UINT32_MAX } from \"./utils/int.ts\";\nimport { utf8Decode } from \"./utils/utf8.ts\";\nimport { ensureUint8Array } from \"./utils/typedArrays.ts\";\nimport { CachedKeyDecoder } from \"./CachedKeyDecoder.ts\";\nimport { DecodeError } from \"./DecodeError.ts\";\nimport type { ContextOf } from \"./context.ts\";\nimport type { ExtensionCodecType } from \"./ExtensionCodec.ts\";\nimport type { KeyDecoder } from \"./CachedKeyDecoder.ts\";\n\nexport type DecoderOptions<ContextType = undefined> = Readonly<\n  Partial<{\n    extensionCodec: ExtensionCodecType<ContextType>;\n\n    /**\n     * Decodes Int64 and Uint64 as bigint if it's set to true.\n     * Depends on ES2020's {@link DataView#getBigInt64} and\n     * {@link DataView#getBigUint64}.\n     *\n     * Defaults to false.\n     */\n    useBigInt64: boolean;\n\n    /**\n     * By default, string values will be decoded as UTF-8 strings. However, if this option is true,\n     * string values will be returned as Uint8Arrays without additional decoding.\n     *\n     * This is useful if the strings may contain invalid UTF-8 sequences.\n     *\n     * Note that this option only applies to string values, not map keys. Additionally, when\n     * enabled, raw string length is limited by the maxBinLength option.\n     */\n    rawStrings: boolean;\n\n    /**\n     * Maximum string length.\n     *\n     * Defaults to 4_294_967_295 (UINT32_MAX).\n     */\n    maxStrLength: number;\n    /**\n     * Maximum binary length.\n     *\n     * Defaults to 4_294_967_295 (UINT32_MAX).\n     */\n    maxBinLength: number;\n    /**\n     * Maximum array length.\n     *\n     * Defaults to 4_294_967_295 (UINT32_MAX).\n     */\n    maxArrayLength: number;\n    /**\n     * Maximum map length.\n     *\n     * Defaults to 4_294_967_295 (UINT32_MAX).\n     */\n    maxMapLength: number;\n    /**\n     * Maximum extension length.\n     *\n     * Defaults to 4_294_967_295 (UINT32_MAX).\n     */\n    maxExtLength: number;\n\n    /**\n     * An object key decoder. Defaults to the shared instance of {@link CachedKeyDecoder}.\n     * `null` is a special value to disable the use of the key decoder at all.\n     */\n    keyDecoder: KeyDecoder | null;\n\n    /**\n     * A function to convert decoded map key to a valid JS key type.\n     *\n     * Defaults to a function that throws an error if the key is not a string or a number.\n     */\n    mapKeyConverter: (key: unknown) => MapKeyType;\n  }>\n> &\n  ContextOf<ContextType>;\n\nconst STATE_ARRAY = \"array\";\nconst STATE_MAP_KEY = \"map_key\";\nconst STATE_MAP_VALUE = \"map_value\";\n\ntype MapKeyType = string | number;\n\nconst mapKeyConverter = (key: unknown): MapKeyType => {\n  if (typeof key === \"string\" || typeof key === \"number\") {\n    return key;\n  }\n  throw new DecodeError(\"The type of key must be string or number but \" + typeof key);\n};\n\ntype StackMapState = {\n  type: typeof STATE_MAP_KEY | typeof STATE_MAP_VALUE;\n  size: number;\n  key: MapKeyType | null;\n  readCount: number;\n  map: Record<string, unknown>;\n};\n\ntype StackArrayState = {\n  type: typeof STATE_ARRAY;\n  size: number;\n  array: Array<unknown>;\n  position: number;\n};\n\nclass StackPool {\n  private readonly stack: Array<StackState> = [];\n  private stackHeadPosition = -1;\n\n  public get length(): number {\n    return this.stackHeadPosition + 1;\n  }\n\n  public top(): StackState | undefined {\n    return this.stack[this.stackHeadPosition];\n  }\n\n  public pushArrayState(size: number) {\n    const state = this.getUninitializedStateFromPool() as StackArrayState;\n\n    state.type = STATE_ARRAY;\n    state.position = 0;\n    state.size = size;\n    state.array = new Array(size);\n  }\n\n  public pushMapState(size: number) {\n    const state = this.getUninitializedStateFromPool() as StackMapState;\n\n    state.type = STATE_MAP_KEY;\n    state.readCount = 0;\n    state.size = size;\n    state.map = {};\n  }\n\n  private getUninitializedStateFromPool() {\n    this.stackHeadPosition++;\n\n    if (this.stackHeadPosition === this.stack.length) {\n      const partialState: Partial<StackState> = {\n        type: undefined,\n        size: 0,\n        array: undefined,\n        position: 0,\n        readCount: 0,\n        map: undefined,\n        key: null,\n      };\n\n      this.stack.push(partialState as StackState);\n    }\n\n    return this.stack[this.stackHeadPosition];\n  }\n\n  public release(state: StackState): void {\n    const topStackState = this.stack[this.stackHeadPosition];\n\n    if (topStackState !== state) {\n      throw new Error(\"Invalid stack state. Released state is not on top of the stack.\");\n    }\n\n    if (state.type === STATE_ARRAY) {\n      const partialState = state as Partial<StackArrayState>;\n      partialState.size = 0;\n      partialState.array = undefined;\n      partialState.position = 0;\n      partialState.type = undefined;\n    }\n\n    if (state.type === STATE_MAP_KEY || state.type === STATE_MAP_VALUE) {\n      const partialState = state as Partial<StackMapState>;\n      partialState.size = 0;\n      partialState.map = undefined;\n      partialState.readCount = 0;\n      partialState.type = undefined;\n    }\n\n    this.stackHeadPosition--;\n  }\n\n  public reset(): void {\n    this.stack.length = 0;\n    this.stackHeadPosition = -1;\n  }\n}\n\ntype StackState = StackArrayState | StackMapState;\n\nconst HEAD_BYTE_REQUIRED = -1;\n\nconst EMPTY_VIEW = new DataView<ArrayBufferLike>(new ArrayBuffer(0));\nconst EMPTY_BYTES = new Uint8Array<ArrayBufferLike>(EMPTY_VIEW.buffer);\n\ntry {\n  // IE11: The spec says it should throw RangeError,\n  // IE11: but in IE11 it throws TypeError.\n  EMPTY_VIEW.getInt8(0);\n} catch (e) {\n  if (!(e instanceof RangeError)) {\n    throw new Error(\n      \"This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access\",\n    );\n  }\n}\n\nconst MORE_DATA = new RangeError(\"Insufficient data\");\n\nconst sharedCachedKeyDecoder = new CachedKeyDecoder();\n\nexport class Decoder<ContextType = undefined> {\n  private readonly extensionCodec: ExtensionCodecType<ContextType>;\n  private readonly context: ContextType;\n  private readonly useBigInt64: boolean;\n  private readonly rawStrings: boolean;\n  private readonly maxStrLength: number;\n  private readonly maxBinLength: number;\n  private readonly maxArrayLength: number;\n  private readonly maxMapLength: number;\n  private readonly maxExtLength: number;\n  private readonly keyDecoder: KeyDecoder | null;\n  private readonly mapKeyConverter: (key: unknown) => MapKeyType;\n\n  private totalPos = 0;\n  private pos = 0;\n\n  private view = EMPTY_VIEW;\n  private bytes = EMPTY_BYTES;\n  private headByte = HEAD_BYTE_REQUIRED;\n  private readonly stack = new StackPool();\n\n  private entered = false;\n\n  public constructor(options?: DecoderOptions<ContextType>) {\n    this.extensionCodec = options?.extensionCodec ?? (ExtensionCodec.defaultCodec as ExtensionCodecType<ContextType>);\n    this.context = (options as { context: ContextType } | undefined)?.context as ContextType; // needs a type assertion because EncoderOptions has no context property when ContextType is undefined\n\n    this.useBigInt64 = options?.useBigInt64 ?? false;\n    this.rawStrings = options?.rawStrings ?? false;\n    this.maxStrLength = options?.maxStrLength ?? UINT32_MAX;\n    this.maxBinLength = options?.maxBinLength ?? UINT32_MAX;\n    this.maxArrayLength = options?.maxArrayLength ?? UINT32_MAX;\n    this.maxMapLength = options?.maxMapLength ?? UINT32_MAX;\n    this.maxExtLength = options?.maxExtLength ?? UINT32_MAX;\n    this.keyDecoder = options?.keyDecoder !== undefined ? options.keyDecoder : sharedCachedKeyDecoder;\n    this.mapKeyConverter = options?.mapKeyConverter ?? mapKeyConverter;\n  }\n\n  private clone(): Decoder<ContextType> {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n    return new Decoder({\n      extensionCodec: this.extensionCodec,\n      context: this.context,\n      useBigInt64: this.useBigInt64,\n      rawStrings: this.rawStrings,\n      maxStrLength: this.maxStrLength,\n      maxBinLength: this.maxBinLength,\n      maxArrayLength: this.maxArrayLength,\n      maxMapLength: this.maxMapLength,\n      maxExtLength: this.maxExtLength,\n      keyDecoder: this.keyDecoder,\n    } as any);\n  }\n\n  private reinitializeState() {\n    this.totalPos = 0;\n    this.headByte = HEAD_BYTE_REQUIRED;\n    this.stack.reset();\n\n    // view, bytes, and pos will be re-initialized in setBuffer()\n  }\n\n  private setBuffer(buffer: ArrayLike<number> | ArrayBufferView | ArrayBufferLike): void {\n    const bytes = ensureUint8Array(buffer);\n    this.bytes = bytes;\n    this.view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n    this.pos = 0;\n  }\n\n  private appendBuffer(buffer: ArrayLike<number> | ArrayBufferView | ArrayBufferLike): void {\n    if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {\n      this.setBuffer(buffer);\n    } else {\n      const remainingData = this.bytes.subarray(this.pos);\n      const newData = ensureUint8Array(buffer);\n\n      // concat remainingData + newData\n      const newBuffer = new Uint8Array(remainingData.length + newData.length);\n      newBuffer.set(remainingData);\n      newBuffer.set(newData, remainingData.length);\n      this.setBuffer(newBuffer);\n    }\n  }\n\n  private hasRemaining(size: number) {\n    return this.view.byteLength - this.pos >= size;\n  }\n\n  private createExtraByteError(posToShow: number): Error {\n    const { view, pos } = this;\n    return new RangeError(`Extra ${view.byteLength - pos} of ${view.byteLength} byte(s) found at buffer[${posToShow}]`);\n  }\n\n  /**\n   * @throws {@link DecodeError}\n   * @throws {@link RangeError}\n   */\n  public decode(buffer: ArrayLike<number> | ArrayBufferView | ArrayBufferLike): unknown {\n    if (this.entered) {\n      const instance = this.clone();\n      return instance.decode(buffer);\n    }\n\n    try {\n      this.entered = true;\n\n      this.reinitializeState();\n      this.setBuffer(buffer);\n\n      const object = this.doDecodeSync();\n      if (this.hasRemaining(1)) {\n        throw this.createExtraByteError(this.pos);\n      }\n      return object;\n    } finally {\n      this.entered = false;\n    }\n  }\n\n  public *decodeMulti(buffer: ArrayLike<number> | ArrayBufferView | ArrayBufferLike): Generator<unknown, void, unknown> {\n    if (this.entered) {\n      const instance = this.clone();\n      yield* instance.decodeMulti(buffer);\n      return;\n    }\n\n    try {\n      this.entered = true;\n\n      this.reinitializeState();\n      this.setBuffer(buffer);\n\n      while (this.hasRemaining(1)) {\n        yield this.doDecodeSync();\n      }\n    } finally {\n      this.entered = false;\n    }\n  }\n\n  public async decodeAsync(stream: AsyncIterable<ArrayLike<number> | ArrayBufferView | ArrayBufferLike>): Promise<unknown> {\n    if (this.entered) {\n      const instance = this.clone();\n      return instance.decodeAsync(stream);\n    }\n\n    try {\n      this.entered = true;\n\n      let decoded = false;\n      let object: unknown;\n      for await (const buffer of stream) {\n        if (decoded) {\n          this.entered = false;\n          throw this.createExtraByteError(this.totalPos);\n        }\n\n        this.appendBuffer(buffer);\n\n        try {\n          object = this.doDecodeSync();\n          decoded = true;\n        } catch (e) {\n          if (!(e instanceof RangeError)) {\n            throw e; // rethrow\n          }\n          // fallthrough\n        }\n        this.totalPos += this.pos;\n      }\n\n      if (decoded) {\n        if (this.hasRemaining(1)) {\n          throw this.createExtraByteError(this.totalPos);\n        }\n        return object;\n      }\n\n      const { headByte, pos, totalPos } = this;\n      throw new RangeError(\n        `Insufficient data in parsing ${prettyByte(headByte)} at ${totalPos} (${pos} in the current buffer)`,\n      );\n    } finally {\n      this.entered = false;\n    }\n  }\n\n  public decodeArrayStream(\n    stream: AsyncIterable<ArrayLike<number> | ArrayBufferView | ArrayBufferLike>,\n  ): AsyncGenerator<unknown, void, unknown> {\n    return this.decodeMultiAsync(stream, true);\n  }\n\n  public decodeStream(stream: AsyncIterable<ArrayLike<number> | ArrayBufferView | ArrayBufferLike>): AsyncGenerator<unknown, void, unknown> {\n    return this.decodeMultiAsync(stream, false);\n  }\n\n  private async *decodeMultiAsync(stream: AsyncIterable<ArrayLike<number> | ArrayBufferView | ArrayBufferLike>, isArray: boolean): AsyncGenerator<unknown, void, unknown> {\n    if (this.entered) {\n      const instance = this.clone();\n      yield* instance.decodeMultiAsync(stream, isArray);\n      return;\n    }\n\n    try {\n      this.entered = true;\n\n      let isArrayHeaderRequired = isArray;\n      let arrayItemsLeft = -1;\n\n      for await (const buffer of stream) {\n        if (isArray && arrayItemsLeft === 0) {\n          throw this.createExtraByteError(this.totalPos);\n        }\n\n        this.appendBuffer(buffer);\n\n        if (isArrayHeaderRequired) {\n          arrayItemsLeft = this.readArraySize();\n          isArrayHeaderRequired = false;\n          this.complete();\n        }\n\n        try {\n          while (true) {\n            yield this.doDecodeSync();\n            if (--arrayItemsLeft === 0) {\n              break;\n            }\n          }\n        } catch (e) {\n          if (!(e instanceof RangeError)) {\n            throw e; // rethrow\n          }\n          // fallthrough\n        }\n        this.totalPos += this.pos;\n      }\n    } finally {\n      this.entered = false;\n    }\n  }\n\n  private doDecodeSync(): unknown {\n    DECODE: while (true) {\n      const headByte = this.readHeadByte();\n      let object: unknown;\n\n      if (headByte >= 0xe0) {\n        // negative fixint (111x xxxx) 0xe0 - 0xff\n        object = headByte - 0x100;\n      } else if (headByte < 0xc0) {\n        if (headByte < 0x80) {\n          // positive fixint (0xxx xxxx) 0x00 - 0x7f\n          object = headByte;\n        } else if (headByte < 0x90) {\n          // fixmap (1000 xxxx) 0x80 - 0x8f\n          const size = headByte - 0x80;\n          if (size !== 0) {\n            this.pushMapState(size);\n            this.complete();\n            continue DECODE;\n          } else {\n            object = {};\n          }\n        } else if (headByte < 0xa0) {\n          // fixarray (1001 xxxx) 0x90 - 0x9f\n          const size = headByte - 0x90;\n          if (size !== 0) {\n            this.pushArrayState(size);\n            this.complete();\n            continue DECODE;\n          } else {\n            object = [];\n          }\n        } else {\n          // fixstr (101x xxxx) 0xa0 - 0xbf\n          const byteLength = headByte - 0xa0;\n          object = this.decodeString(byteLength, 0);\n        }\n      } else if (headByte === 0xc0) {\n        // nil\n        object = null;\n      } else if (headByte === 0xc2) {\n        // false\n        object = false;\n      } else if (headByte === 0xc3) {\n        // true\n        object = true;\n      } else if (headByte === 0xca) {\n        // float 32\n        object = this.readF32();\n      } else if (headByte === 0xcb) {\n        // float 64\n        object = this.readF64();\n      } else if (headByte === 0xcc) {\n        // uint 8\n        object = this.readU8();\n      } else if (headByte === 0xcd) {\n        // uint 16\n        object = this.readU16();\n      } else if (headByte === 0xce) {\n        // uint 32\n        object = this.readU32();\n      } else if (headByte === 0xcf) {\n        // uint 64\n        if (this.useBigInt64) {\n          object = this.readU64AsBigInt();\n        } else {\n          object = this.readU64();\n        }\n      } else if (headByte === 0xd0) {\n        // int 8\n        object = this.readI8();\n      } else if (headByte === 0xd1) {\n        // int 16\n        object = this.readI16();\n      } else if (headByte === 0xd2) {\n        // int 32\n        object = this.readI32();\n      } else if (headByte === 0xd3) {\n        // int 64\n        if (this.useBigInt64) {\n          object = this.readI64AsBigInt();\n        } else {\n          object = this.readI64();\n        }\n      } else if (headByte === 0xd9) {\n        // str 8\n        const byteLength = this.lookU8();\n        object = this.decodeString(byteLength, 1);\n      } else if (headByte === 0xda) {\n        // str 16\n        const byteLength = this.lookU16();\n        object = this.decodeString(byteLength, 2);\n      } else if (headByte === 0xdb) {\n        // str 32\n        const byteLength = this.lookU32();\n        object = this.decodeString(byteLength, 4);\n      } else if (headByte === 0xdc) {\n        // array 16\n        const size = this.readU16();\n        if (size !== 0) {\n          this.pushArrayState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = [];\n        }\n      } else if (headByte === 0xdd) {\n        // array 32\n        const size = this.readU32();\n        if (size !== 0) {\n          this.pushArrayState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = [];\n        }\n      } else if (headByte === 0xde) {\n        // map 16\n        const size = this.readU16();\n        if (size !== 0) {\n          this.pushMapState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = {};\n        }\n      } else if (headByte === 0xdf) {\n        // map 32\n        const size = this.readU32();\n        if (size !== 0) {\n          this.pushMapState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = {};\n        }\n      } else if (headByte === 0xc4) {\n        // bin 8\n        const size = this.lookU8();\n        object = this.decodeBinary(size, 1);\n      } else if (headByte === 0xc5) {\n        // bin 16\n        const size = this.lookU16();\n        object = this.decodeBinary(size, 2);\n      } else if (headByte === 0xc6) {\n        // bin 32\n        const size = this.lookU32();\n        object = this.decodeBinary(size, 4);\n      } else if (headByte === 0xd4) {\n        // fixext 1\n        object = this.decodeExtension(1, 0);\n      } else if (headByte === 0xd5) {\n        // fixext 2\n        object = this.decodeExtension(2, 0);\n      } else if (headByte === 0xd6) {\n        // fixext 4\n        object = this.decodeExtension(4, 0);\n      } else if (headByte === 0xd7) {\n        // fixext 8\n        object = this.decodeExtension(8, 0);\n      } else if (headByte === 0xd8) {\n        // fixext 16\n        object = this.decodeExtension(16, 0);\n      } else if (headByte === 0xc7) {\n        // ext 8\n        const size = this.lookU8();\n        object = this.decodeExtension(size, 1);\n      } else if (headByte === 0xc8) {\n        // ext 16\n        const size = this.lookU16();\n        object = this.decodeExtension(size, 2);\n      } else if (headByte === 0xc9) {\n        // ext 32\n        const size = this.lookU32();\n        object = this.decodeExtension(size, 4);\n      } else {\n        throw new DecodeError(`Unrecognized type byte: ${prettyByte(headByte)}`);\n      }\n\n      this.complete();\n\n      const stack = this.stack;\n      while (stack.length > 0) {\n        // arrays and maps\n        const state = stack.top()!;\n        if (state.type === STATE_ARRAY) {\n          state.array[state.position] = object;\n          state.position++;\n          if (state.position === state.size) {\n            object = state.array;\n            stack.release(state);\n          } else {\n            continue DECODE;\n          }\n        } else if (state.type === STATE_MAP_KEY) {\n          if (object === \"__proto__\") {\n            throw new DecodeError(\"The key __proto__ is not allowed\");\n          }\n\n          state.key = this.mapKeyConverter(object);\n          state.type = STATE_MAP_VALUE;\n          continue DECODE;\n        } else {\n          // it must be `state.type === State.MAP_VALUE` here\n\n          state.map[state.key!] = object;\n          state.readCount++;\n\n          if (state.readCount === state.size) {\n            object = state.map;\n            stack.release(state);\n          } else {\n            state.key = null;\n            state.type = STATE_MAP_KEY;\n            continue DECODE;\n          }\n        }\n      }\n\n      return object;\n    }\n  }\n\n  private readHeadByte(): number {\n    if (this.headByte === HEAD_BYTE_REQUIRED) {\n      this.headByte = this.readU8();\n      // console.log(\"headByte\", prettyByte(this.headByte));\n    }\n\n    return this.headByte;\n  }\n\n  private complete(): void {\n    this.headByte = HEAD_BYTE_REQUIRED;\n  }\n\n  private readArraySize(): number {\n    const headByte = this.readHeadByte();\n\n    switch (headByte) {\n      case 0xdc:\n        return this.readU16();\n      case 0xdd:\n        return this.readU32();\n      default: {\n        if (headByte < 0xa0) {\n          return headByte - 0x90;\n        } else {\n          throw new DecodeError(`Unrecognized array type byte: ${prettyByte(headByte)}`);\n        }\n      }\n    }\n  }\n\n  private pushMapState(size: number) {\n    if (size > this.maxMapLength) {\n      throw new DecodeError(`Max length exceeded: map length (${size}) > maxMapLengthLength (${this.maxMapLength})`);\n    }\n\n    this.stack.pushMapState(size);\n  }\n\n  private pushArrayState(size: number) {\n    if (size > this.maxArrayLength) {\n      throw new DecodeError(`Max length exceeded: array length (${size}) > maxArrayLength (${this.maxArrayLength})`);\n    }\n\n    this.stack.pushArrayState(size);\n  }\n\n  private decodeString(byteLength: number, headerOffset: number): string | Uint8Array {\n    if (!this.rawStrings || this.stateIsMapKey()) {\n      return this.decodeUtf8String(byteLength, headerOffset);\n    }\n    return this.decodeBinary(byteLength, headerOffset);\n  }\n\n  /**\n   * @throws {@link RangeError}\n   */\n  private decodeUtf8String(byteLength: number, headerOffset: number): string {\n    if (byteLength > this.maxStrLength) {\n      throw new DecodeError(\n        `Max length exceeded: UTF-8 byte length (${byteLength}) > maxStrLength (${this.maxStrLength})`,\n      );\n    }\n\n    if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {\n      throw MORE_DATA;\n    }\n\n    const offset = this.pos + headerOffset;\n    let object: string;\n    if (this.stateIsMapKey() && this.keyDecoder?.canBeCached(byteLength)) {\n      object = this.keyDecoder.decode(this.bytes, offset, byteLength);\n    } else {\n      object = utf8Decode(this.bytes, offset, byteLength);\n    }\n    this.pos += headerOffset + byteLength;\n    return object;\n  }\n\n  private stateIsMapKey(): boolean {\n    if (this.stack.length > 0) {\n      const state = this.stack.top()!;\n      return state.type === STATE_MAP_KEY;\n    }\n    return false;\n  }\n\n  /**\n   * @throws {@link RangeError}\n   */\n  private decodeBinary(byteLength: number, headOffset: number): Uint8Array {\n    if (byteLength > this.maxBinLength) {\n      throw new DecodeError(`Max length exceeded: bin length (${byteLength}) > maxBinLength (${this.maxBinLength})`);\n    }\n\n    if (!this.hasRemaining(byteLength + headOffset)) {\n      throw MORE_DATA;\n    }\n\n    const offset = this.pos + headOffset;\n    const object = this.bytes.subarray(offset, offset + byteLength);\n    this.pos += headOffset + byteLength;\n    return object;\n  }\n\n  private decodeExtension(size: number, headOffset: number): unknown {\n    if (size > this.maxExtLength) {\n      throw new DecodeError(`Max length exceeded: ext length (${size}) > maxExtLength (${this.maxExtLength})`);\n    }\n\n    const extType = this.view.getInt8(this.pos + headOffset);\n    const data = this.decodeBinary(size, headOffset + 1 /* extType */);\n    return this.extensionCodec.decode(data, extType, this.context);\n  }\n\n  private lookU8() {\n    return this.view.getUint8(this.pos);\n  }\n\n  private lookU16() {\n    return this.view.getUint16(this.pos);\n  }\n\n  private lookU32() {\n    return this.view.getUint32(this.pos);\n  }\n\n  private readU8(): number {\n    const value = this.view.getUint8(this.pos);\n    this.pos++;\n    return value;\n  }\n\n  private readI8(): number {\n    const value = this.view.getInt8(this.pos);\n    this.pos++;\n    return value;\n  }\n\n  private readU16(): number {\n    const value = this.view.getUint16(this.pos);\n    this.pos += 2;\n    return value;\n  }\n\n  private readI16(): number {\n    const value = this.view.getInt16(this.pos);\n    this.pos += 2;\n    return value;\n  }\n\n  private readU32(): number {\n    const value = this.view.getUint32(this.pos);\n    this.pos += 4;\n    return value;\n  }\n\n  private readI32(): number {\n    const value = this.view.getInt32(this.pos);\n    this.pos += 4;\n    return value;\n  }\n\n  private readU64(): number {\n    const value = getUint64(this.view, this.pos);\n    this.pos += 8;\n    return value;\n  }\n\n  private readI64(): number {\n    const value = getInt64(this.view, this.pos);\n    this.pos += 8;\n    return value;\n  }\n\n  private readU64AsBigInt(): bigint {\n    const value = this.view.getBigUint64(this.pos);\n    this.pos += 8;\n    return value;\n  }\n\n  private readI64AsBigInt(): bigint {\n    const value = this.view.getBigInt64(this.pos);\n    this.pos += 8;\n    return value;\n  }\n\n  private readF32() {\n    const value = this.view.getFloat32(this.pos);\n    this.pos += 4;\n    return value;\n  }\n\n  private readF64() {\n    const value = this.view.getFloat64(this.pos);\n    this.pos += 8;\n    return value;\n  }\n}\n", "import { Decoder } from \"./Decoder.ts\";\nimport type { DecoderOptions } from \"./Decoder.ts\";\nimport type { SplitUndefined } from \"./context.ts\";\n\n/**\n * It decodes a single MessagePack object in a buffer.\n *\n * This is a synchronous decoding function.\n * See other variants for asynchronous decoding: {@link decodeAsync}, {@link decodeMultiStream}, or {@link decodeArrayStream}.\n *\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\nexport function decode<ContextType = undefined>(\n  buffer: ArrayLike<number> | ArrayBufferView | ArrayBufferLike,\n  options?: DecoderOptions<SplitUndefined<ContextType>>,\n): unknown {\n  const decoder = new Decoder(options);\n  return decoder.decode(buffer);\n}\n\n/**\n * It decodes multiple MessagePack objects in a buffer.\n * This is corresponding to {@link decodeMultiStream}.\n *\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\nexport function decodeMulti<ContextType = undefined>(\n  buffer: ArrayLike<number> | BufferSource,\n  options?: DecoderOptions<SplitUndefined<ContextType>>,\n): Generator<unknown, void, unknown> {\n  const decoder = new Decoder(options);\n  return decoder.decodeMulti(buffer);\n}\n", "import { decode, encode } from '@msgpack/msgpack'\nimport type { AnyOrama } from '@orama/orama'\nimport { create, load, save } from '@orama/orama'\nimport type { PersistenceFormat, Runtime } from './types.js'\n// @ts-expect-error dpack does not expose types\nimport * as dpack from 'dpack'\nimport { METHOD_MOVED, UNSUPPORTED_FORMAT } from './errors.js'\nimport { detectRuntime } from './utils.js'\nimport { serializeOramaInstance, deserializeOramaInstance } from './seqproto.js'\n\nconst hexFromMap: Record<string, number> = {\n  0: 0,\n  1: 1,\n  2: 2,\n  3: 3,\n  4: 4,\n  5: 5,\n  6: 6,\n  7: 7,\n  8: 8,\n  9: 9,\n  a: 10,\n  b: 11,\n  c: 12,\n  d: 13,\n  e: 14,\n  f: 15\n}\nconst hexToMap = Object.keys(hexFromMap)\n\n/* c8 ignore next 13 */\nfunction slowHexToBuffer(hex: string): Uint8Array {\n  const bytes = new Uint8Array(Math.floor(hex.length / 2))\n\n  hex = hex.toLowerCase()\n  for (let i = 0; i < hex.length; i++) {\n    const a = hexFromMap[hex[i * 2]]\n    const b = hexFromMap[hex[i * 2 + 1]]\n    if (a === undefined || b === undefined) {\n      break\n    }\n    bytes[i] = (a << 4) | b\n  }\n  return bytes\n}\n\n/* c8 ignore next 5 */\nfunction slowHexToString(bytes: Uint8Array): string {\n  return Array.from(bytes || [])\n    .map((b) => hexToMap[b >> 4] + hexToMap[b & 15])\n    .join('')\n}\n\nexport async function persist<T extends AnyOrama>(\n  db: T,\n  format: PersistenceFormat = 'binary',\n  runtime?: Runtime\n): Promise<string | Buffer | ArrayBuffer> {\n  if (!runtime) {\n    runtime = detectRuntime()\n  }\n\n  const dbExport = await save(db)\n  let serialized: string | Buffer | ArrayBuffer\n\n  switch (format) {\n    case 'json':\n      serialized = JSON.stringify(dbExport)\n      break\n    case 'dpack':\n      serialized = dpack.serialize(dbExport)\n      break\n    case 'binary': {\n      const msgpack = encode(dbExport)\n      if (runtime === 'node') {\n        serialized = Buffer.from(msgpack.buffer, msgpack.byteOffset, msgpack.byteLength)\n        serialized = serialized.toString('hex')\n        /* c8 ignore next 3 */\n      } else {\n        serialized = slowHexToString(msgpack)\n      }\n      break\n    }\n    case 'seqproto':\n      serialized = serializeOramaInstance(db)\n      break\n    default:\n      throw new Error(UNSUPPORTED_FORMAT(format))\n  }\n\n  return serialized\n}\n\nexport async function restore<T extends AnyOrama>(\n  format: PersistenceFormat,\n  data: string | Buffer | ArrayBuffer,\n  runtime?: Runtime\n): Promise<T> {\n  if (!runtime) {\n    runtime = detectRuntime()\n  }\n\n  const db = create({\n    schema: {\n      __placeholder: 'string'\n    }\n  })\n  let deserialized: any\n\n  switch (format) {\n    case 'json':\n      deserialized = JSON.parse((data as any).toString())\n      break\n    case 'dpack':\n      deserialized = dpack.parse(data)\n      break\n    case 'binary': {\n      if (runtime === 'node') {\n        data = Buffer.from((data as any).toString(), 'hex')\n        /* c8 ignore next 3 */\n      } else {\n        // @ts-ignore\n        data = slowHexToBuffer(data as string) as Buffer\n      }\n      deserialized = decode(data)\n      break\n    }\n    case 'seqproto':\n      {\n        let ab: ArrayBuffer\n        if (data instanceof ArrayBuffer) {\n          ab = data\n        } else if (ArrayBuffer.isView(data)) {\n          const view = data as unknown as Uint8Array\n          const slice = view.buffer.slice(view.byteOffset, view.byteOffset + view.byteLength)\n          const copy = new Uint8Array(view.byteLength)\n          copy.set(new Uint8Array(slice))\n          ab = copy.buffer\n        } else if (typeof (data as any) === 'string') {\n          // If somehow a base64 or hex string is passed (should not happen in current flow)\n          const buf = Buffer.from(data as string, 'binary')\n          const slice = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength)\n          const copy = new Uint8Array(buf.byteLength)\n          copy.set(new Uint8Array(slice))\n          ab = copy.buffer\n        } else {\n          throw new Error('Unsupported data type for seqproto restore')\n        }\n        deserialized = deserializeOramaInstance(ab)\n      }\n      break\n    default:\n      throw new Error(UNSUPPORTED_FORMAT(format))\n  }\n\n  load(db, deserialized)\n\n  return db as unknown as T\n}\n\nexport async function persistToFile<T extends AnyOrama>(\n  db: T,\n  format: PersistenceFormat = 'json',\n  path?: string,\n  runtime?: Runtime\n): Promise<never> {\n  throw new Error(METHOD_MOVED('persistToFile'))\n}\n\nexport async function restoreFromFile<T extends AnyOrama>(\n  format: PersistenceFormat = 'json',\n  path?: string,\n  runtime?: Runtime\n): Promise<never> {\n  throw new Error(METHOD_MOVED('restoreFromFile'))\n}\n", "function capitalize(word: string): string {\n  return `${word.slice(0, 1).toUpperCase()}${word.slice(1).toLowerCase()}`\n}\n\nexport function UNSUPPORTED_FORMAT(format: string): string {\n  return `Unsupported serialization format: ${format}`\n}\n\nexport function FILESYSTEM_NOT_SUPPORTED_ON_RUNTIME(runtime: string): string {\n  return `Filesystem access is not supported on ${capitalize(runtime)}`\n}\n\nexport function METHOD_MOVED(method: string): string {\n  return `Function ${method} has been moved to the \"/server\" module. \\n\\nImport it via \"import { ${method} } from 'orama/plugin-data-persistence/server'\". \\n\\nRead more at https://docs.orama.com/docs/orama-js/plugins/plugin-data-persistence.`\n}\n", "import type { Runtime } from './types.js'\n\nexport function detectRuntime(): Runtime {\n  /* c8 ignore next 11 */\n  if (typeof process !== 'undefined' && process.versions !== undefined) {\n    return 'node'\n\n    // @ts-expect-error \"Deno\" global variable is defined in Deno only\n  } else if (typeof Deno !== 'undefined') {\n    return 'deno'\n    // @ts-expect-error \"Bun\" global variable is defined in Bun only\n  } else if (typeof Bun !== 'undefined') {\n    return 'bun'\n  } else if (typeof window !== 'undefined') {\n    return 'browser'\n  }\n\n  return 'unknown'\n}\n", "const TYPE_FLOAT = 0;\nconst TYPE_UINT32 = 1;\nconst TYPE_INT32 = 2;\nconst POW_2_32 = 2 ** 32;\nexport function createSer({ bufferSize } = {}) {\n    const size = bufferSize !== null && bufferSize !== void 0 ? bufferSize : 2 ** 24;\n    if (size >= POW_2_32) {\n        throw new Error('bufferSize option must be strictly less than 2 ** 32');\n    }\n    const buffer = new ArrayBuffer(size);\n    return {\n        index: 0,\n        buffer,\n        uint32Array: new Uint32Array(buffer),\n        float32Array: new Float32Array(buffer),\n        reset: function () { this.index = 0; },\n        serializeBoolean,\n        serializeUInt32,\n        serializeFloat32,\n        serializeNumber,\n        serializeString,\n        serializeArray,\n        serializeIterable,\n        serializeIndexableArray,\n        unsafeSerializeUint32Array,\n        getBuffer: function () { return this.buffer.slice(0, this.index * 4); }\n    };\n}\nexport function createDes(buffer) {\n    const n32 = Math.floor(buffer.byteLength / 4);\n    return {\n        index: 0,\n        buffer,\n        uint32Array: new Uint32Array(buffer, 0, n32),\n        float32Array: new Float32Array(buffer, 0, n32),\n        setBuffer: function (buffer, byteOffset, byteLength) {\n            if (typeof byteOffset === 'number' && typeof byteLength === 'number') {\n                this.index = Math.floor(byteOffset / 4);\n                const n32 = this.index + Math.ceil(byteLength / 4);\n                this.buffer = buffer;\n                this.uint32Array = new Uint32Array(buffer, 0, n32);\n                this.float32Array = new Float32Array(buffer, 0, n32);\n                return;\n            }\n            const n32 = Math.floor(buffer.byteLength / 4);\n            this.buffer = buffer;\n            this.index = 0;\n            this.uint32Array = new Uint32Array(buffer, 0, n32);\n            this.float32Array = new Float32Array(buffer, 0, n32);\n        },\n        deserializeBoolean,\n        deserializeUInt32,\n        deserializeFloat32,\n        deserializeNumber,\n        deserializeString,\n        deserializeArray,\n        deserializeIterable,\n        getArrayElements,\n        unsafeDeserializeUint32Array\n    };\n}\nfunction serializeBoolean(b) {\n    this.uint32Array[this.index++] = b ? 1 : 0;\n}\nfunction deserializeBoolean() {\n    return this.uint32Array[this.index++] === 1;\n}\nfunction serializeUInt32(n) {\n    this.uint32Array[this.index++] = n;\n}\nfunction deserializeUInt32() {\n    return this.uint32Array[this.index++];\n}\nfunction serializeFloat32(n) {\n    this.float32Array[this.index++] = n;\n}\nfunction deserializeFloat32() {\n    return this.float32Array[this.index++];\n}\nfunction serializeNumber(n) {\n    // If it's not an integer\n    if (n % 1 !== 0) {\n        this.uint32Array[this.index++] = TYPE_FLOAT;\n        this.serializeFloat32(n);\n    }\n    else if (n >= 0) {\n        this.uint32Array[this.index++] = TYPE_UINT32;\n        this.serializeUInt32(n);\n    }\n    else {\n        this.uint32Array[this.index++] = TYPE_INT32;\n        this.uint32Array[this.index++] = POW_2_32 + n;\n    }\n}\nfunction deserializeNumber() {\n    const type = this.uint32Array[this.index++];\n    if (type === TYPE_FLOAT) {\n        return this.deserializeFloat32();\n    }\n    else if (type === TYPE_UINT32) {\n        return this.deserializeUInt32();\n    }\n    else if (type === TYPE_INT32) {\n        return this.uint32Array[this.index++] - POW_2_32;\n    }\n    else {\n        throw new Error('Unknown type');\n    }\n}\nconst textEncoder = new TextEncoder();\nfunction serializeString(str) {\n    const r = textEncoder.encodeInto(str, new Uint8Array(this.buffer, (this.index + 1) * 4));\n    this.uint32Array[this.index] = r.written;\n    this.index += Math.ceil(r.written / 4) + 1;\n}\nconst textDecoder = new TextDecoder();\nfunction deserializeString() {\n    const len = this.uint32Array[this.index++];\n    const decoded = textDecoder.decode(new Uint8Array(this.buffer, this.index * 4, len));\n    this.index += Math.ceil(len / 4);\n    return decoded;\n}\nfunction serializeArray(arr, serialize) {\n    const len = arr.length;\n    this.serializeUInt32(len);\n    for (let i = 0; i < len; i++) {\n        serialize(this, arr[i]);\n    }\n}\nfunction deserializeArray(deserialize) {\n    const len = this.deserializeUInt32();\n    const arr = new Array(len);\n    for (let i = 0; i < len; i++) {\n        arr[i] = deserialize(this);\n    }\n    return arr;\n}\nfunction serializeIterable(iterable, serialize) {\n    // Keep space for the length\n    const currentIndex = this.index++;\n    let n = 0;\n    for (const t of iterable) {\n        n++;\n        serialize(this, t);\n    }\n    this.uint32Array[currentIndex] = n;\n}\nfunction deserializeIterable(deserialize) {\n    const len = this.deserializeUInt32();\n    const aGeneratorObject = (function* (des) {\n        for (let i = 0; i < len; i++) {\n            yield deserialize(des);\n        }\n    })(this);\n    return {\n        [Symbol.iterator]() {\n            return aGeneratorObject;\n        }\n    };\n}\nfunction unsafeSerializeUint32Array(arr) {\n    const length = Math.ceil(arr.byteLength / 4);\n    this.uint32Array[this.index++] = length;\n    this.uint32Array.set(arr, this.index);\n    this.index += length;\n}\nfunction unsafeDeserializeUint32Array() {\n    const byteLength = this.uint32Array[this.index++];\n    const d = new Uint32Array(this.buffer, this.index * 4, byteLength);\n    this.index += byteLength;\n    return d;\n}\nfunction serializeIndexableArray(arr, serialize) {\n    const l = arr.length;\n    this.uint32Array[this.index++] = l;\n    let indexOffsets = this.index;\n    // Skip the length of the array twice\n    // to store the offset + length of the array element\n    this.index += l * 2;\n    for (let i = 0; i < l; i++) {\n        const offsetStart = this.index;\n        serialize(this, arr[i]);\n        const offsetEnd = this.index;\n        this.uint32Array[indexOffsets++] = offsetStart;\n        this.uint32Array[indexOffsets++] = offsetEnd - offsetStart;\n    }\n}\nfunction getArrayElements(indexes, deserialize) {\n    const currentIndex = this.index + 1;\n    const l = indexes.length;\n    const arr = new Array(l);\n    for (let i = 0; i < l; i++) {\n        const indexOffset = currentIndex + indexes[i] * 2;\n        const start = this.uint32Array[indexOffset];\n        const end = this.uint32Array[indexOffset + 1];\n        arr[i] = deserialize(this, start * 4, end);\n    }\n    return arr;\n}\n", "import type { Ser, Des } from 'seqproto'\nimport type { RawData, AnyOrama } from '@orama/orama'\nimport { save } from '@orama/orama'\nimport { createSer, createDes } from 'seqproto'\n\ntype JSONLike = null | string | number | boolean | undefined | JSONLike[] | { [k: string]: JSONLike }\n\n// Fast serializers for known Orama structures\nfunction serializeStringArray(ser: Ser, arr: string[]): void {\n  ser.serializeUInt32(arr.length)\n  for (let i = 0; i < arr.length; i++) {\n    ser.serializeString(arr[i])\n  }\n}\n\nfunction deserializeStringArray(des: Des): string[] {\n  const len = des.deserializeUInt32()\n  const arr = new Array<string>(len)\n  for (let i = 0; i < len; i++) {\n    arr[i] = des.deserializeString()\n  }\n  return arr\n}\n\nfunction serializeNumberArray(ser: Ser, arr: number[]): void {\n  ser.serializeUInt32(arr.length)\n  for (let i = 0; i < arr.length; i++) {\n    ser.serializeNumber(arr[i])\n  }\n}\n\nfunction deserializeNumberArray(des: Des): number[] {\n  const len = des.deserializeUInt32()\n  const arr = new Array<number>(len)\n  for (let i = 0; i < len; i++) {\n    arr[i] = des.deserializeNumber()\n  }\n  return arr\n}\n\nfunction serializeIndexNode(ser: Ser, type: string, node: any): void {\n  if (type === 'Radix') {\n    ser.serializeUInt32(1) // Radix marker\n    ser.serializeString(node.w || '')\n    ser.serializeString(node.s || '')\n    ser.serializeBoolean(node.e || false)\n    ser.serializeString(node.k || '')\n\n    // Serialize array d\n    if (Array.isArray(node.d)) {\n      ser.serializeUInt32(node.d.length)\n      for (let i = 0; i < node.d.length; i++) {\n        ser.serializeNumber(node.d[i])\n      }\n    } else {\n      ser.serializeUInt32(0)\n    }\n\n    // Serialize children c\n    if (Array.isArray(node.c)) {\n      ser.serializeUInt32(node.c.length)\n      for (let i = 0; i < node.c.length; i++) {\n        const [key, child] = node.c[i]\n        ser.serializeString(key)\n        serializeIndexNode(ser, 'Radix', child)\n      }\n    } else {\n      ser.serializeUInt32(0)\n    }\n  } else if (type === 'Flat') {\n    ser.serializeUInt32(2) // Flat marker\n    // Serialize Flat tree structure\n    if (node.numberToDocumentId && Array.isArray(node.numberToDocumentId)) {\n      ser.serializeUInt32(node.numberToDocumentId.length)\n      for (let i = 0; i < node.numberToDocumentId.length; i++) {\n        const [key, ids] = node.numberToDocumentId[i]\n        ser.serializeString(String(key))\n        // Ensure ids are strings\n        const stringIds = Array.isArray(ids) ? ids.map((id) => String(id)) : []\n        serializeStringArray(ser, stringIds)\n      }\n    } else {\n      ser.serializeUInt32(0)\n    }\n  } else {\n    // Unknown type, serialize as generic object\n    ser.serializeUInt32(0)\n    serializeValue(ser, node)\n  }\n}\n\nfunction deserializeIndexNode(des: Des): any {\n  const nodeType = des.deserializeUInt32()\n\n  if (nodeType === 1) {\n    // Radix node\n    const w = des.deserializeString()\n    const s = des.deserializeString()\n    const e = des.deserializeBoolean()\n    const k = des.deserializeString()\n    const d = deserializeNumberArray(des)\n\n    const childrenLen = des.deserializeUInt32()\n    const c = []\n    for (let i = 0; i < childrenLen; i++) {\n      const key = des.deserializeString()\n      const child = deserializeIndexNode(des)\n      c.push([key, child])\n    }\n\n    return { w: w || '', s: s || '', e, k: k || '', d, c }\n  } else if (nodeType === 2) {\n    // Flat node\n    const numberToDocumentIdLen = des.deserializeUInt32()\n    const numberToDocumentId = []\n    for (let i = 0; i < numberToDocumentIdLen; i++) {\n      const key = des.deserializeString()\n      const ids = deserializeStringArray(des)\n      numberToDocumentId.push([key, ids])\n    }\n    return { numberToDocumentId }\n  } else {\n    // Generic fallback\n    return deserializeValue(des)\n  }\n}\n\nfunction serializeStringToNumberMap(ser: Ser, map: Record<string, number>): void {\n  const keys = Object.keys(map)\n  ser.serializeUInt32(keys.length)\n  const keysLength = keys.length\n  for (let i = 0; i < keysLength; i++) {\n    const key = keys[i]\n    ser.serializeString(key)\n    ser.serializeNumber(map[key])\n  }\n}\n\nfunction deserializeStringToNumberMap(des: Des): Record<string, number> {\n  const len = des.deserializeUInt32()\n  const map: Record<string, number> = {}\n  for (let i = 0; i < len; i++) {\n    const key = des.deserializeString()\n    map[key] = des.deserializeNumber()\n  }\n  return map\n}\n\n// Serialization for frequencies: field -> docId -> token -> number\nfunction serializeFrequencies(ser: Ser, frequencies: any): void {\n  const fieldKeys = Object.keys(frequencies)\n  const fieldKeysLength = fieldKeys.length\n  ser.serializeUInt32(fieldKeysLength)\n  for (let i = 0; i < fieldKeysLength; i++) {\n    const field = fieldKeys[i]\n    ser.serializeString(field)\n    const docFreqs = frequencies[field] || {}\n    const docIds = Object.keys(docFreqs)\n    ser.serializeUInt32(docIds.length)\n    for (let j = 0; j < docIds.length; j++) {\n      const docId = docIds[j]\n      ser.serializeString(docId)\n      serializeStringToNumberMap(ser, docFreqs[docId] || {})\n    }\n  }\n}\n\nfunction deserializeFrequencies(des: Des): any {\n  const fieldCount = des.deserializeUInt32()\n  const frequencies: any = {}\n  for (let i = 0; i < fieldCount; i++) {\n    const field = des.deserializeString()\n    const docCount = des.deserializeUInt32()\n    const docFreqs: any = {}\n    for (let j = 0; j < docCount; j++) {\n      const docId = des.deserializeString()\n      docFreqs[docId] = deserializeStringToNumberMap(des)\n    }\n    frequencies[field] = docFreqs\n  }\n  return frequencies\n}\n\n// Serialization for tokenOccurrences: field -> token -> number\nfunction serializeTokenOccurrences(ser: Ser, tokenOccurrences: any): void {\n  const fieldKeys = Object.keys(tokenOccurrences)\n  ser.serializeUInt32(fieldKeys.length)\n  for (let i = 0; i < fieldKeys.length; i++) {\n    const field = fieldKeys[i]\n    ser.serializeString(field)\n    serializeStringToNumberMap(ser, tokenOccurrences[field] || {})\n  }\n}\n\nfunction deserializeTokenOccurrences(des: Des): any {\n  const fieldCount = des.deserializeUInt32()\n  const tokenOccurrences: any = {}\n  for (let i = 0; i < fieldCount; i++) {\n    const field = des.deserializeString()\n    tokenOccurrences[field] = deserializeStringToNumberMap(des)\n  }\n  return tokenOccurrences\n}\n\n// Fallback for version 1 compatibility\nfunction serializeValue(ser: Ser, value: JSONLike): void {\n  if (value === null) {\n    ser.serializeUInt32(0)\n    return\n  }\n  if (value === undefined) {\n    ser.serializeUInt32(1)\n    return\n  }\n\n  const t = typeof value\n  if (t === 'string') {\n    ser.serializeUInt32(2)\n    ser.serializeString(value as string)\n    return\n  }\n  if (t === 'number') {\n    ser.serializeUInt32(3)\n    ser.serializeNumber(value as number)\n    return\n  }\n  if (t === 'boolean') {\n    ser.serializeUInt32(4)\n    ser.serializeBoolean(value as boolean)\n    return\n  }\n  if (Array.isArray(value)) {\n    ser.serializeUInt32(5)\n    ser.serializeUInt32(value.length)\n    for (let i = 0; i < value.length; i++) {\n      serializeValue(ser, value[i] as JSONLike)\n    }\n    return\n  }\n\n  // Object\n  ser.serializeUInt32(6)\n  const obj = value as Record<string, JSONLike>\n  const keys = Object.keys(obj)\n  const keysLength = keys.length\n  ser.serializeUInt32(keysLength)\n  for (let i = 0; i < keysLength; i++) {\n    const key = keys[i]\n    ser.serializeString(key)\n    serializeValue(ser, obj[key])\n  }\n}\n\nfunction deserializeValue(des: Des): JSONLike {\n  const type = des.deserializeUInt32()\n  if (type === 0) return null\n  if (type === 1) return undefined\n  if (type === 2) return des.deserializeString()\n  if (type === 3) return des.deserializeNumber()\n  if (type === 4) return des.deserializeBoolean()\n  if (type === 5) {\n    const len = des.deserializeUInt32()\n    const arr = new Array<JSONLike>(len)\n    for (let i = 0; i < len; i++) {\n      arr[i] = deserializeValue(des)\n    }\n    return arr\n  }\n  if (type === 6) {\n    const len = des.deserializeUInt32()\n    const obj: Record<string, JSONLike> = {}\n    for (let i = 0; i < len; i++) {\n      const key = des.deserializeString()\n      obj[key] = deserializeValue(des)\n    }\n    return obj\n  }\n  throw new Error(`Unknown type: ${type}`)\n}\n\n/**\n * Serialize an Orama instance using seqproto with schema-aware optimization.\n */\nexport function serializeOramaInstance<T extends AnyOrama>(db: T): ArrayBuffer {\n  const raw = save(db) as any\n  const ser = createSer()\n\n  ser.serializeUInt32(2) // format version\n\n  // Inline serialize internalDocumentIDStore\n  const idStore = raw.internalDocumentIDStore?.internalIdToId || []\n  ser.serializeUInt32(idStore.length)\n  for (let i = 0; i < idStore.length; i++) {\n    ser.serializeString(idStore[i])\n  }\n\n  // Inline serialize docs\n  ser.serializeUInt32(raw.docs?.count || 0)\n  if (raw.docs?.docs) {\n    const docKeys = Object.keys(raw.docs.docs)\n    ser.serializeUInt32(docKeys.length)\n    for (let i = 0; i < docKeys.length; i++) {\n      const docId = docKeys[i]\n      const doc = raw.docs.docs[docId]\n      ser.serializeString(docId)\n\n      const docFields = Object.keys(doc)\n      ser.serializeUInt32(docFields.length)\n      for (let j = 0; j < docFields.length; j++) {\n        const field = docFields[j]\n        ser.serializeString(field)\n        const value = doc[field]\n\n        if (Array.isArray(value)) {\n          ser.serializeUInt32(value.length | 0x80000000) // high bit = array\n          for (let k = 0; k < value.length; k++) {\n            ser.serializeString(value[k])\n          }\n        } else {\n          ser.serializeUInt32(0) // non-array\n          ser.serializeString(String(value))\n        }\n      }\n    }\n  } else {\n    ser.serializeUInt32(0)\n  }\n\n  // Inline serialize indexes\n  if (raw.index?.indexes) {\n    const indexKeys = Object.keys(raw.index.indexes)\n    ser.serializeUInt32(indexKeys.length)\n    for (let i = 0; i < indexKeys.length; i++) {\n      const key = indexKeys[i]\n      const index = raw.index.indexes[key]\n      ser.serializeString(key)\n      ser.serializeString(index.type || '')\n      ser.serializeBoolean(index.isArray || false)\n\n      // Inline index node serialization\n      const node = index.node || {}\n      if (index.type === 'Radix') {\n        ser.serializeUInt32(1)\n        ser.serializeString(node.w || '')\n        ser.serializeString(node.s || '')\n        ser.serializeBoolean(node.e || false)\n        ser.serializeString(node.k || '')\n\n        const d = node.d || []\n        ser.serializeUInt32(d.length)\n        for (let j = 0; j < d.length; j++) {\n          ser.serializeNumber(d[j])\n        }\n\n        const c = node.c || []\n        ser.serializeUInt32(c.length)\n        for (let j = 0; j < c.length; j++) {\n          const [cKey, child] = c[j]\n          ser.serializeString(cKey)\n          serializeIndexNode(ser, 'Radix', child) // Keep recursion for children\n        }\n      } else if (index.type === 'Flat') {\n        ser.serializeUInt32(2)\n        const ntdi = node.numberToDocumentId || []\n        ser.serializeUInt32(ntdi.length)\n        for (let j = 0; j < ntdi.length; j++) {\n          const [key, ids] = ntdi[j]\n          ser.serializeString(String(key))\n          const stringIds = Array.isArray(ids) ? ids.map((id) => String(id)) : []\n          ser.serializeUInt32(stringIds.length)\n          for (let k = 0; k < stringIds.length; k++) {\n            ser.serializeString(stringIds[k])\n          }\n        }\n      } else {\n        ser.serializeUInt32(0)\n      }\n    }\n  } else {\n    ser.serializeUInt32(0)\n  }\n\n  // Inline serialize searchableProperties\n  const searchProps = raw.index?.searchableProperties || []\n  ser.serializeUInt32(searchProps.length)\n  for (let i = 0; i < searchProps.length; i++) {\n    ser.serializeString(searchProps[i])\n  }\n\n  // Inline serialize searchablePropertiesWithTypes\n  const propsWithTypes = raw.index?.searchablePropertiesWithTypes || {}\n  const propsKeys = Object.keys(propsWithTypes)\n  ser.serializeUInt32(propsKeys.length)\n  for (let i = 0; i < propsKeys.length; i++) {\n    const key = propsKeys[i]\n    ser.serializeString(key)\n    ser.serializeString(propsWithTypes[key])\n  }\n\n  // Use function calls for the most complex nested structures only\n  serializeFrequencies(ser, raw.index?.frequencies || {})\n  serializeTokenOccurrences(ser, raw.index?.tokenOccurrences || {})\n\n  // Inline serialize avgFieldLength\n  const avgFL = raw.index?.avgFieldLength || {}\n  const avgKeys = Object.keys(avgFL)\n  ser.serializeUInt32(avgKeys.length)\n  for (let i = 0; i < avgKeys.length; i++) {\n    const key = avgKeys[i]\n    ser.serializeString(key)\n    ser.serializeNumber(avgFL[key])\n  }\n\n  // Inline serialize fieldLengths\n  const fieldLengths = raw.index?.fieldLengths || {}\n  const fieldKeys = Object.keys(fieldLengths)\n  ser.serializeUInt32(fieldKeys.length)\n  for (let i = 0; i < fieldKeys.length; i++) {\n    const field = fieldKeys[i]\n    ser.serializeString(field)\n    const fieldData = fieldLengths[field] || {}\n    const fieldDataKeys = Object.keys(fieldData)\n    ser.serializeUInt32(fieldDataKeys.length)\n    for (let j = 0; j < fieldDataKeys.length; j++) {\n      const key = fieldDataKeys[j]\n      ser.serializeString(key)\n      ser.serializeNumber(fieldData[key])\n    }\n  }\n\n  ser.serializeString(raw.language || '')\n\n  // Serialize pinning rules\n  const pinningRules = raw.pinning?.rules || []\n  ser.serializeUInt32(pinningRules.length)\n  for (let i = 0; i < pinningRules.length; i++) {\n    const [ruleId, rule] = pinningRules[i]\n    ser.serializeString(ruleId)\n    serializeValue(ser, rule as JSONLike)\n  }\n\n  return ser.getBuffer()\n}\n\n/**\n * Deserialize a previously serialized snapshot with schema-aware deserialization.\n */\nexport function deserializeOramaInstance(buffer: ArrayBuffer): RawData {\n  const des = createDes(buffer as any)\n  const version = des.deserializeUInt32()\n\n  if (version === 1) {\n    // Fallback to old generic deserialization\n    const raw = deserializeValue(des) as unknown as RawData\n    return raw\n  }\n\n  if (version !== 2) {\n    throw new Error(`Unsupported seqproto Orama serialization version: ${version}`)\n  }\n\n  // Schema-aware deserialization\n  const raw: any = {}\n\n  // Inline deserialize internalDocumentIDStore\n  const idStoreLen = des.deserializeUInt32()\n  const internalIdToId = new Array(idStoreLen)\n  for (let i = 0; i < idStoreLen; i++) {\n    internalIdToId[i] = des.deserializeString()\n  }\n  raw.internalDocumentIDStore = { internalIdToId }\n\n  // Inline deserialize docs\n  const docCount = des.deserializeUInt32()\n  const docsLength = des.deserializeUInt32()\n  const docs: any = {}\n\n  for (let i = 0; i < docsLength; i++) {\n    const docId = des.deserializeString()\n    const doc: any = {}\n\n    const fieldCount = des.deserializeUInt32()\n    for (let j = 0; j < fieldCount; j++) {\n      const field = des.deserializeString()\n      const arrayInfo = des.deserializeUInt32()\n\n      if (arrayInfo & 0x80000000) {\n        // High bit set = array\n        const len = arrayInfo & 0x7fffffff\n        const arr = new Array(len)\n        for (let k = 0; k < len; k++) {\n          arr[k] = des.deserializeString()\n        }\n        doc[field] = arr\n      } else {\n        doc[field] = des.deserializeString()\n      }\n    }\n    docs[docId] = doc\n  }\n\n  raw.docs = { docs, count: docCount }\n\n  // Inline deserialize indexes\n  const indexCount = des.deserializeUInt32()\n  const indexes: any = {}\n\n  for (let i = 0; i < indexCount; i++) {\n    const key = des.deserializeString()\n    const type = des.deserializeString()\n    const isArray = des.deserializeBoolean()\n\n    // Inline index node deserialization\n    const nodeType = des.deserializeUInt32()\n    let node: any\n\n    if (nodeType === 1) {\n      // Radix node\n      const w = des.deserializeString()\n      const s = des.deserializeString()\n      const e = des.deserializeBoolean()\n      const k = des.deserializeString()\n\n      const dLen = des.deserializeUInt32()\n      const d = new Array(dLen)\n      for (let j = 0; j < dLen; j++) {\n        d[j] = des.deserializeNumber()\n      }\n\n      const cLen = des.deserializeUInt32()\n      const c = new Array(cLen)\n      for (let j = 0; j < cLen; j++) {\n        const cKey = des.deserializeString()\n        const child = deserializeIndexNode(des) // Keep recursion for children\n        c[j] = [cKey, child]\n      }\n\n      node = { w, s, e, k, d, c }\n    } else if (nodeType === 2) {\n      // Flat node\n      const ntdiLen = des.deserializeUInt32()\n      const numberToDocumentId = new Array(ntdiLen)\n      for (let j = 0; j < ntdiLen; j++) {\n        const key = des.deserializeString()\n        const idsLen = des.deserializeUInt32()\n        const ids = new Array(idsLen)\n        for (let k = 0; k < idsLen; k++) {\n          ids[k] = des.deserializeString()\n        }\n        numberToDocumentId[j] = [key, ids]\n      }\n      node = { numberToDocumentId }\n    } else {\n      node = {}\n    }\n\n    indexes[key] = { type, isArray, node }\n  }\n\n  // Inline deserialize searchableProperties\n  const searchPropLen = des.deserializeUInt32()\n  const searchableProperties = new Array(searchPropLen)\n  for (let i = 0; i < searchPropLen; i++) {\n    searchableProperties[i] = des.deserializeString()\n  }\n\n  // Inline deserialize searchablePropertiesWithTypes\n  const propsWithTypesLen = des.deserializeUInt32()\n  const searchablePropertiesWithTypes: any = {}\n  for (let i = 0; i < propsWithTypesLen; i++) {\n    const key = des.deserializeString()\n    const value = des.deserializeString()\n    searchablePropertiesWithTypes[key] = value\n  }\n\n  // Keep function calls for complex nested structures\n  const frequencies = deserializeFrequencies(des)\n  const tokenOccurrences = deserializeTokenOccurrences(des)\n\n  // Inline deserialize avgFieldLength\n  const avgFLLen = des.deserializeUInt32()\n  const avgFieldLength: any = {}\n  for (let i = 0; i < avgFLLen; i++) {\n    const key = des.deserializeString()\n    avgFieldLength[key] = des.deserializeNumber()\n  }\n\n  // Inline deserialize fieldLengths\n  const fieldLengthsLen = des.deserializeUInt32()\n  const fieldLengths: any = {}\n  for (let i = 0; i < fieldLengthsLen; i++) {\n    const field = des.deserializeString()\n    const dataLen = des.deserializeUInt32()\n    const fieldData: any = {}\n    for (let j = 0; j < dataLen; j++) {\n      const key = des.deserializeString()\n      fieldData[key] = des.deserializeNumber()\n    }\n    fieldLengths[field] = fieldData\n  }\n\n  raw.index = {\n    indexes,\n    vectorIndexes: {},\n    searchableProperties,\n    searchablePropertiesWithTypes,\n    frequencies,\n    tokenOccurrences,\n    avgFieldLength,\n    fieldLengths\n  }\n\n  // Deserialize language\n  raw.language = des.deserializeString()\n\n  // Deserialize pinning rules\n  const pinningRulesLen = des.deserializeUInt32()\n  const pinningRules = new Array(pinningRulesLen)\n  for (let i = 0; i < pinningRulesLen; i++) {\n    const ruleId = des.deserializeString()\n    const rule = deserializeValue(des)\n    pinningRules[i] = [ruleId, rule]\n  }\n  raw.pinning = { rules: pinningRules }\n\n  // Set empty sorting - it will be reconstructed by Orama when needed\n  raw.sorting = {}\n\n  return raw as RawData\n}\n\n/**\n * Utility to deep-clone raw data using seqproto encode/decode cycle.\n */\nexport function cloneRawData(raw: RawData): RawData {\n  const ser = createSer()\n  ser.serializeUInt32(1)\n  serializeValue(ser, raw as unknown as JSONLike)\n  const des = createDes(ser.getBuffer() as any)\n  des.deserializeUInt32() // version\n  return deserializeValue(des) as unknown as RawData\n}\n"],
  "mappings": "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",
  "names": ["constructor", "property", "blockProperty", "serialize", "buffer", "serialize", "instanceProperty", "propertyIndex", "parse", "property", "serialize", "buffer", "parse", "target", "dpackBuffer", "serialize", "parse", "encode", "decode", "size", "UNSUPPORTED_FORMAT", "format", "METHOD_MOVED", "method", "detectRuntime", "process", "versions", "undefined", "Deno", "Bun", "window", "buffer", "n32", "serialize", "serializeStringArray", "ser", "arr", "serializeUInt32", "length", "i", "serializeString", "deserializeStringArray", "des", "len", "deserializeUInt32", "Array", "deserializeString", "deserializeNumberArray", "des", "len", "deserializeUInt32", "arr", "Array", "i", "deserializeNumber", "serializeIndexNode", "ser", "type", "node", "serializeUInt32", "serializeString", "w", "s", "serializeBoolean", "e", "k", "isArray", "d", "length", "serializeNumber", "c", "key", "child", "numberToDocumentId", "ids", "String", "stringIds", "map", "id", "serializeStringArray", "serializeValue", "deserializeIndexNode", "nodeType", "deserializeString", "deserializeBoolean", "childrenLen", "push", "numberToDocumentIdLen", "deserializeStringArray", "deserializeValue", "serializeStringToNumberMap", "keys", "Object", "keysLength", "deserializeStringToNumberMap", "serializeFrequencies", "frequencies", "fieldKeys", "fieldKeysLength", "field", "docFreqs", "docIds", "j", "docId", "deserializeFrequencies", "fieldCount", "docCount", "serializeTokenOccurrences", "tokenOccurrences", "deserializeTokenOccurrences", "value", "undefined", "t", "obj", "Error", "serializeOramaInstance", "db", "raw", "save", "createSer", "idStore", "internalDocumentIDStore", "internalIdToId", "docs", "count", "docKeys", "doc", "docFields", "index", "indexes", "indexKeys", "cKey", "ntdi", "searchProps", "searchableProperties", "propsWithTypes", "searchablePropertiesWithTypes", "propsKeys", "avgFL", "avgFieldLength", "avgKeys", "fieldLengths", "fieldData", "fieldDataKeys", "language", "pinningRules", "pinning", "rules", "ruleId", "rule", "getBuffer", "deserializeOramaInstance", "buffer", "createDes", "version", "idStoreLen", "docsLength", "arrayInfo", "indexCount", "dLen", "cLen", "ntdiLen", "idsLen", "searchPropLen", "propsWithTypesLen", "avgFLLen", "fieldLengthsLen", "dataLen", "vectorIndexes", "pinningRulesLen", "sorting", "hexFromMap", "a", "b", "c", "d", "e", "f", "hexToMap", "Object", "keys", "slowHexToBuffer", "hex", "bytes", "Uint8Array", "Math", "floor", "length", "toLowerCase", "i", "undefined", "slowHexToString", "Array", "from", "map", "join", "persist", "db", "format", "runtime", "detectRuntime", "dbExport", "save", "serialized", "JSON", "stringify", "serialize", "msgpack", "encode", "Buffer", "buffer", "byteOffset", "byteLength", "toString", "serializeOramaInstance", "Error", "UNSUPPORTED_FORMAT", "restore", "data", "create", "schema", "__placeholder", "deserialized", "parse", "decode", "ab", "ArrayBuffer", "isView", "view", "slice", "copy", "set", "buf", "deserializeOramaInstance", "load", "persistToFile", "path", "METHOD_MOVED", "restoreFromFile"]
}
