{"version":3,"sources":["../src/seqproto.ts"],"sourcesContent":["import type { Ser, Des } from 'seqproto'\nimport type { RawData, AnyOrama } from '@orama/orama'\nimport { save } from '@orama/orama'\nimport { createSer, createDes } from 'seqproto'\n\ntype JSONLike = null | string | number | boolean | undefined | JSONLike[] | { [k: string]: JSONLike }\n\n// Fast serializers for known Orama structures\nfunction serializeStringArray(ser: Ser, arr: string[]): void {\n  ser.serializeUInt32(arr.length)\n  for (let i = 0; i < arr.length; i++) {\n    ser.serializeString(arr[i])\n  }\n}\n\nfunction deserializeStringArray(des: Des): string[] {\n  const len = des.deserializeUInt32()\n  const arr = new Array<string>(len)\n  for (let i = 0; i < len; i++) {\n    arr[i] = des.deserializeString()\n  }\n  return arr\n}\n\nfunction serializeNumberArray(ser: Ser, arr: number[]): void {\n  ser.serializeUInt32(arr.length)\n  for (let i = 0; i < arr.length; i++) {\n    ser.serializeNumber(arr[i])\n  }\n}\n\nfunction deserializeNumberArray(des: Des): number[] {\n  const len = des.deserializeUInt32()\n  const arr = new Array<number>(len)\n  for (let i = 0; i < len; i++) {\n    arr[i] = des.deserializeNumber()\n  }\n  return arr\n}\n\nfunction serializeIndexNode(ser: Ser, type: string, node: any): void {\n  if (type === 'Radix') {\n    ser.serializeUInt32(1) // Radix marker\n    ser.serializeString(node.w || '')\n    ser.serializeString(node.s || '')\n    ser.serializeBoolean(node.e || false)\n    ser.serializeString(node.k || '')\n\n    // Serialize array d\n    if (Array.isArray(node.d)) {\n      ser.serializeUInt32(node.d.length)\n      for (let i = 0; i < node.d.length; i++) {\n        ser.serializeNumber(node.d[i])\n      }\n    } else {\n      ser.serializeUInt32(0)\n    }\n\n    // Serialize children c\n    if (Array.isArray(node.c)) {\n      ser.serializeUInt32(node.c.length)\n      for (let i = 0; i < node.c.length; i++) {\n        const [key, child] = node.c[i]\n        ser.serializeString(key)\n        serializeIndexNode(ser, 'Radix', child)\n      }\n    } else {\n      ser.serializeUInt32(0)\n    }\n  } else if (type === 'Flat') {\n    ser.serializeUInt32(2) // Flat marker\n    // Serialize Flat tree structure\n    if (node.numberToDocumentId && Array.isArray(node.numberToDocumentId)) {\n      ser.serializeUInt32(node.numberToDocumentId.length)\n      for (let i = 0; i < node.numberToDocumentId.length; i++) {\n        const [key, ids] = node.numberToDocumentId[i]\n        ser.serializeString(String(key))\n        // Ensure ids are strings\n        const stringIds = Array.isArray(ids) ? ids.map((id) => String(id)) : []\n        serializeStringArray(ser, stringIds)\n      }\n    } else {\n      ser.serializeUInt32(0)\n    }\n  } else {\n    // Unknown type, serialize as generic object\n    ser.serializeUInt32(0)\n    serializeValue(ser, node)\n  }\n}\n\nfunction deserializeIndexNode(des: Des): any {\n  const nodeType = des.deserializeUInt32()\n\n  if (nodeType === 1) {\n    // Radix node\n    const w = des.deserializeString()\n    const s = des.deserializeString()\n    const e = des.deserializeBoolean()\n    const k = des.deserializeString()\n    const d = deserializeNumberArray(des)\n\n    const childrenLen = des.deserializeUInt32()\n    const c = []\n    for (let i = 0; i < childrenLen; i++) {\n      const key = des.deserializeString()\n      const child = deserializeIndexNode(des)\n      c.push([key, child])\n    }\n\n    return { w: w || '', s: s || '', e, k: k || '', d, c }\n  } else if (nodeType === 2) {\n    // Flat node\n    const numberToDocumentIdLen = des.deserializeUInt32()\n    const numberToDocumentId = []\n    for (let i = 0; i < numberToDocumentIdLen; i++) {\n      const key = des.deserializeString()\n      const ids = deserializeStringArray(des)\n      numberToDocumentId.push([key, ids])\n    }\n    return { numberToDocumentId }\n  } else {\n    // Generic fallback\n    return deserializeValue(des)\n  }\n}\n\nfunction serializeStringToNumberMap(ser: Ser, map: Record<string, number>): void {\n  const keys = Object.keys(map)\n  ser.serializeUInt32(keys.length)\n  const keysLength = keys.length\n  for (let i = 0; i < keysLength; i++) {\n    const key = keys[i]\n    ser.serializeString(key)\n    ser.serializeNumber(map[key])\n  }\n}\n\nfunction deserializeStringToNumberMap(des: Des): Record<string, number> {\n  const len = des.deserializeUInt32()\n  const map: Record<string, number> = {}\n  for (let i = 0; i < len; i++) {\n    const key = des.deserializeString()\n    map[key] = des.deserializeNumber()\n  }\n  return map\n}\n\n// Serialization for frequencies: field -> docId -> token -> number\nfunction serializeFrequencies(ser: Ser, frequencies: any): void {\n  const fieldKeys = Object.keys(frequencies)\n  const fieldKeysLength = fieldKeys.length\n  ser.serializeUInt32(fieldKeysLength)\n  for (let i = 0; i < fieldKeysLength; i++) {\n    const field = fieldKeys[i]\n    ser.serializeString(field)\n    const docFreqs = frequencies[field] || {}\n    const docIds = Object.keys(docFreqs)\n    ser.serializeUInt32(docIds.length)\n    for (let j = 0; j < docIds.length; j++) {\n      const docId = docIds[j]\n      ser.serializeString(docId)\n      serializeStringToNumberMap(ser, docFreqs[docId] || {})\n    }\n  }\n}\n\nfunction deserializeFrequencies(des: Des): any {\n  const fieldCount = des.deserializeUInt32()\n  const frequencies: any = {}\n  for (let i = 0; i < fieldCount; i++) {\n    const field = des.deserializeString()\n    const docCount = des.deserializeUInt32()\n    const docFreqs: any = {}\n    for (let j = 0; j < docCount; j++) {\n      const docId = des.deserializeString()\n      docFreqs[docId] = deserializeStringToNumberMap(des)\n    }\n    frequencies[field] = docFreqs\n  }\n  return frequencies\n}\n\n// Serialization for tokenOccurrences: field -> token -> number\nfunction serializeTokenOccurrences(ser: Ser, tokenOccurrences: any): void {\n  const fieldKeys = Object.keys(tokenOccurrences)\n  ser.serializeUInt32(fieldKeys.length)\n  for (let i = 0; i < fieldKeys.length; i++) {\n    const field = fieldKeys[i]\n    ser.serializeString(field)\n    serializeStringToNumberMap(ser, tokenOccurrences[field] || {})\n  }\n}\n\nfunction deserializeTokenOccurrences(des: Des): any {\n  const fieldCount = des.deserializeUInt32()\n  const tokenOccurrences: any = {}\n  for (let i = 0; i < fieldCount; i++) {\n    const field = des.deserializeString()\n    tokenOccurrences[field] = deserializeStringToNumberMap(des)\n  }\n  return tokenOccurrences\n}\n\n// Fallback for version 1 compatibility\nfunction serializeValue(ser: Ser, value: JSONLike): void {\n  if (value === null) {\n    ser.serializeUInt32(0)\n    return\n  }\n  if (value === undefined) {\n    ser.serializeUInt32(1)\n    return\n  }\n\n  const t = typeof value\n  if (t === 'string') {\n    ser.serializeUInt32(2)\n    ser.serializeString(value as string)\n    return\n  }\n  if (t === 'number') {\n    ser.serializeUInt32(3)\n    ser.serializeNumber(value as number)\n    return\n  }\n  if (t === 'boolean') {\n    ser.serializeUInt32(4)\n    ser.serializeBoolean(value as boolean)\n    return\n  }\n  if (Array.isArray(value)) {\n    ser.serializeUInt32(5)\n    ser.serializeUInt32(value.length)\n    for (let i = 0; i < value.length; i++) {\n      serializeValue(ser, value[i] as JSONLike)\n    }\n    return\n  }\n\n  // Object\n  ser.serializeUInt32(6)\n  const obj = value as Record<string, JSONLike>\n  const keys = Object.keys(obj)\n  const keysLength = keys.length\n  ser.serializeUInt32(keysLength)\n  for (let i = 0; i < keysLength; i++) {\n    const key = keys[i]\n    ser.serializeString(key)\n    serializeValue(ser, obj[key])\n  }\n}\n\nfunction deserializeValue(des: Des): JSONLike {\n  const type = des.deserializeUInt32()\n  if (type === 0) return null\n  if (type === 1) return undefined\n  if (type === 2) return des.deserializeString()\n  if (type === 3) return des.deserializeNumber()\n  if (type === 4) return des.deserializeBoolean()\n  if (type === 5) {\n    const len = des.deserializeUInt32()\n    const arr = new Array<JSONLike>(len)\n    for (let i = 0; i < len; i++) {\n      arr[i] = deserializeValue(des)\n    }\n    return arr\n  }\n  if (type === 6) {\n    const len = des.deserializeUInt32()\n    const obj: Record<string, JSONLike> = {}\n    for (let i = 0; i < len; i++) {\n      const key = des.deserializeString()\n      obj[key] = deserializeValue(des)\n    }\n    return obj\n  }\n  throw new Error(`Unknown type: ${type}`)\n}\n\n/**\n * Serialize an Orama instance using seqproto with schema-aware optimization.\n */\nexport function serializeOramaInstance<T extends AnyOrama>(db: T): ArrayBuffer {\n  const raw = save(db) as any\n  const ser = createSer()\n\n  ser.serializeUInt32(2) // format version\n\n  // Inline serialize internalDocumentIDStore\n  const idStore = raw.internalDocumentIDStore?.internalIdToId || []\n  ser.serializeUInt32(idStore.length)\n  for (let i = 0; i < idStore.length; i++) {\n    ser.serializeString(idStore[i])\n  }\n\n  // Inline serialize docs\n  ser.serializeUInt32(raw.docs?.count || 0)\n  if (raw.docs?.docs) {\n    const docKeys = Object.keys(raw.docs.docs)\n    ser.serializeUInt32(docKeys.length)\n    for (let i = 0; i < docKeys.length; i++) {\n      const docId = docKeys[i]\n      const doc = raw.docs.docs[docId]\n      ser.serializeString(docId)\n\n      const docFields = Object.keys(doc)\n      ser.serializeUInt32(docFields.length)\n      for (let j = 0; j < docFields.length; j++) {\n        const field = docFields[j]\n        ser.serializeString(field)\n        const value = doc[field]\n\n        if (Array.isArray(value)) {\n          ser.serializeUInt32(value.length | 0x80000000) // high bit = array\n          for (let k = 0; k < value.length; k++) {\n            ser.serializeString(value[k])\n          }\n        } else {\n          ser.serializeUInt32(0) // non-array\n          ser.serializeString(String(value))\n        }\n      }\n    }\n  } else {\n    ser.serializeUInt32(0)\n  }\n\n  // Inline serialize indexes\n  if (raw.index?.indexes) {\n    const indexKeys = Object.keys(raw.index.indexes)\n    ser.serializeUInt32(indexKeys.length)\n    for (let i = 0; i < indexKeys.length; i++) {\n      const key = indexKeys[i]\n      const index = raw.index.indexes[key]\n      ser.serializeString(key)\n      ser.serializeString(index.type || '')\n      ser.serializeBoolean(index.isArray || false)\n\n      // Inline index node serialization\n      const node = index.node || {}\n      if (index.type === 'Radix') {\n        ser.serializeUInt32(1)\n        ser.serializeString(node.w || '')\n        ser.serializeString(node.s || '')\n        ser.serializeBoolean(node.e || false)\n        ser.serializeString(node.k || '')\n\n        const d = node.d || []\n        ser.serializeUInt32(d.length)\n        for (let j = 0; j < d.length; j++) {\n          ser.serializeNumber(d[j])\n        }\n\n        const c = node.c || []\n        ser.serializeUInt32(c.length)\n        for (let j = 0; j < c.length; j++) {\n          const [cKey, child] = c[j]\n          ser.serializeString(cKey)\n          serializeIndexNode(ser, 'Radix', child) // Keep recursion for children\n        }\n      } else if (index.type === 'Flat') {\n        ser.serializeUInt32(2)\n        const ntdi = node.numberToDocumentId || []\n        ser.serializeUInt32(ntdi.length)\n        for (let j = 0; j < ntdi.length; j++) {\n          const [key, ids] = ntdi[j]\n          ser.serializeString(String(key))\n          const stringIds = Array.isArray(ids) ? ids.map((id) => String(id)) : []\n          ser.serializeUInt32(stringIds.length)\n          for (let k = 0; k < stringIds.length; k++) {\n            ser.serializeString(stringIds[k])\n          }\n        }\n      } else {\n        ser.serializeUInt32(0)\n      }\n    }\n  } else {\n    ser.serializeUInt32(0)\n  }\n\n  // Inline serialize searchableProperties\n  const searchProps = raw.index?.searchableProperties || []\n  ser.serializeUInt32(searchProps.length)\n  for (let i = 0; i < searchProps.length; i++) {\n    ser.serializeString(searchProps[i])\n  }\n\n  // Inline serialize searchablePropertiesWithTypes\n  const propsWithTypes = raw.index?.searchablePropertiesWithTypes || {}\n  const propsKeys = Object.keys(propsWithTypes)\n  ser.serializeUInt32(propsKeys.length)\n  for (let i = 0; i < propsKeys.length; i++) {\n    const key = propsKeys[i]\n    ser.serializeString(key)\n    ser.serializeString(propsWithTypes[key])\n  }\n\n  // Use function calls for the most complex nested structures only\n  serializeFrequencies(ser, raw.index?.frequencies || {})\n  serializeTokenOccurrences(ser, raw.index?.tokenOccurrences || {})\n\n  // Inline serialize avgFieldLength\n  const avgFL = raw.index?.avgFieldLength || {}\n  const avgKeys = Object.keys(avgFL)\n  ser.serializeUInt32(avgKeys.length)\n  for (let i = 0; i < avgKeys.length; i++) {\n    const key = avgKeys[i]\n    ser.serializeString(key)\n    ser.serializeNumber(avgFL[key])\n  }\n\n  // Inline serialize fieldLengths\n  const fieldLengths = raw.index?.fieldLengths || {}\n  const fieldKeys = Object.keys(fieldLengths)\n  ser.serializeUInt32(fieldKeys.length)\n  for (let i = 0; i < fieldKeys.length; i++) {\n    const field = fieldKeys[i]\n    ser.serializeString(field)\n    const fieldData = fieldLengths[field] || {}\n    const fieldDataKeys = Object.keys(fieldData)\n    ser.serializeUInt32(fieldDataKeys.length)\n    for (let j = 0; j < fieldDataKeys.length; j++) {\n      const key = fieldDataKeys[j]\n      ser.serializeString(key)\n      ser.serializeNumber(fieldData[key])\n    }\n  }\n\n  ser.serializeString(raw.language || '')\n\n  // Serialize pinning rules\n  const pinningRules = raw.pinning?.rules || []\n  ser.serializeUInt32(pinningRules.length)\n  for (let i = 0; i < pinningRules.length; i++) {\n    const [ruleId, rule] = pinningRules[i]\n    ser.serializeString(ruleId)\n    serializeValue(ser, rule as JSONLike)\n  }\n\n  return ser.getBuffer()\n}\n\n/**\n * Deserialize a previously serialized snapshot with schema-aware deserialization.\n */\nexport function deserializeOramaInstance(buffer: ArrayBuffer): RawData {\n  const des = createDes(buffer as any)\n  const version = des.deserializeUInt32()\n\n  if (version === 1) {\n    // Fallback to old generic deserialization\n    const raw = deserializeValue(des) as unknown as RawData\n    return raw\n  }\n\n  if (version !== 2) {\n    throw new Error(`Unsupported seqproto Orama serialization version: ${version}`)\n  }\n\n  // Schema-aware deserialization\n  const raw: any = {}\n\n  // Inline deserialize internalDocumentIDStore\n  const idStoreLen = des.deserializeUInt32()\n  const internalIdToId = new Array(idStoreLen)\n  for (let i = 0; i < idStoreLen; i++) {\n    internalIdToId[i] = des.deserializeString()\n  }\n  raw.internalDocumentIDStore = { internalIdToId }\n\n  // Inline deserialize docs\n  const docCount = des.deserializeUInt32()\n  const docsLength = des.deserializeUInt32()\n  const docs: any = {}\n\n  for (let i = 0; i < docsLength; i++) {\n    const docId = des.deserializeString()\n    const doc: any = {}\n\n    const fieldCount = des.deserializeUInt32()\n    for (let j = 0; j < fieldCount; j++) {\n      const field = des.deserializeString()\n      const arrayInfo = des.deserializeUInt32()\n\n      if (arrayInfo & 0x80000000) {\n        // High bit set = array\n        const len = arrayInfo & 0x7fffffff\n        const arr = new Array(len)\n        for (let k = 0; k < len; k++) {\n          arr[k] = des.deserializeString()\n        }\n        doc[field] = arr\n      } else {\n        doc[field] = des.deserializeString()\n      }\n    }\n    docs[docId] = doc\n  }\n\n  raw.docs = { docs, count: docCount }\n\n  // Inline deserialize indexes\n  const indexCount = des.deserializeUInt32()\n  const indexes: any = {}\n\n  for (let i = 0; i < indexCount; i++) {\n    const key = des.deserializeString()\n    const type = des.deserializeString()\n    const isArray = des.deserializeBoolean()\n\n    // Inline index node deserialization\n    const nodeType = des.deserializeUInt32()\n    let node: any\n\n    if (nodeType === 1) {\n      // Radix node\n      const w = des.deserializeString()\n      const s = des.deserializeString()\n      const e = des.deserializeBoolean()\n      const k = des.deserializeString()\n\n      const dLen = des.deserializeUInt32()\n      const d = new Array(dLen)\n      for (let j = 0; j < dLen; j++) {\n        d[j] = des.deserializeNumber()\n      }\n\n      const cLen = des.deserializeUInt32()\n      const c = new Array(cLen)\n      for (let j = 0; j < cLen; j++) {\n        const cKey = des.deserializeString()\n        const child = deserializeIndexNode(des) // Keep recursion for children\n        c[j] = [cKey, child]\n      }\n\n      node = { w, s, e, k, d, c }\n    } else if (nodeType === 2) {\n      // Flat node\n      const ntdiLen = des.deserializeUInt32()\n      const numberToDocumentId = new Array(ntdiLen)\n      for (let j = 0; j < ntdiLen; j++) {\n        const key = des.deserializeString()\n        const idsLen = des.deserializeUInt32()\n        const ids = new Array(idsLen)\n        for (let k = 0; k < idsLen; k++) {\n          ids[k] = des.deserializeString()\n        }\n        numberToDocumentId[j] = [key, ids]\n      }\n      node = { numberToDocumentId }\n    } else {\n      node = {}\n    }\n\n    indexes[key] = { type, isArray, node }\n  }\n\n  // Inline deserialize searchableProperties\n  const searchPropLen = des.deserializeUInt32()\n  const searchableProperties = new Array(searchPropLen)\n  for (let i = 0; i < searchPropLen; i++) {\n    searchableProperties[i] = des.deserializeString()\n  }\n\n  // Inline deserialize searchablePropertiesWithTypes\n  const propsWithTypesLen = des.deserializeUInt32()\n  const searchablePropertiesWithTypes: any = {}\n  for (let i = 0; i < propsWithTypesLen; i++) {\n    const key = des.deserializeString()\n    const value = des.deserializeString()\n    searchablePropertiesWithTypes[key] = value\n  }\n\n  // Keep function calls for complex nested structures\n  const frequencies = deserializeFrequencies(des)\n  const tokenOccurrences = deserializeTokenOccurrences(des)\n\n  // Inline deserialize avgFieldLength\n  const avgFLLen = des.deserializeUInt32()\n  const avgFieldLength: any = {}\n  for (let i = 0; i < avgFLLen; i++) {\n    const key = des.deserializeString()\n    avgFieldLength[key] = des.deserializeNumber()\n  }\n\n  // Inline deserialize fieldLengths\n  const fieldLengthsLen = des.deserializeUInt32()\n  const fieldLengths: any = {}\n  for (let i = 0; i < fieldLengthsLen; i++) {\n    const field = des.deserializeString()\n    const dataLen = des.deserializeUInt32()\n    const fieldData: any = {}\n    for (let j = 0; j < dataLen; j++) {\n      const key = des.deserializeString()\n      fieldData[key] = des.deserializeNumber()\n    }\n    fieldLengths[field] = fieldData\n  }\n\n  raw.index = {\n    indexes,\n    vectorIndexes: {},\n    searchableProperties,\n    searchablePropertiesWithTypes,\n    frequencies,\n    tokenOccurrences,\n    avgFieldLength,\n    fieldLengths\n  }\n\n  // Deserialize language\n  raw.language = des.deserializeString()\n\n  // Deserialize pinning rules\n  const pinningRulesLen = des.deserializeUInt32()\n  const pinningRules = new Array(pinningRulesLen)\n  for (let i = 0; i < pinningRulesLen; i++) {\n    const ruleId = des.deserializeString()\n    const rule = deserializeValue(des)\n    pinningRules[i] = [ruleId, rule]\n  }\n  raw.pinning = { rules: pinningRules }\n\n  // Set empty sorting - it will be reconstructed by Orama when needed\n  raw.sorting = {}\n\n  return raw as RawData\n}\n\n/**\n * Utility to deep-clone raw data using seqproto encode/decode cycle.\n */\nexport function cloneRawData(raw: RawData): RawData {\n  const ser = createSer()\n  ser.serializeUInt32(1)\n  serializeValue(ser, raw as unknown as JSONLike)\n  const des = createDes(ser.getBuffer() as any)\n  des.deserializeUInt32() // version\n  return deserializeValue(des) as unknown as RawData\n}\n"],"names":["save","createSer","createDes","serializeStringArray","ser","arr","serializeUInt32","length","i","serializeString","deserializeStringArray","des","len","deserializeUInt32","Array","deserializeString","serializeNumberArray","serializeNumber","deserializeNumberArray","deserializeNumber","serializeIndexNode","type","node","w","s","serializeBoolean","e","k","isArray","d","c","key","child","numberToDocumentId","ids","String","stringIds","map","id","serializeValue","deserializeIndexNode","nodeType","deserializeBoolean","childrenLen","push","numberToDocumentIdLen","deserializeValue","serializeStringToNumberMap","keys","Object","keysLength","deserializeStringToNumberMap","serializeFrequencies","frequencies","fieldKeys","fieldKeysLength","field","docFreqs","docIds","j","docId","deserializeFrequencies","fieldCount","docCount","serializeTokenOccurrences","tokenOccurrences","deserializeTokenOccurrences","value","undefined","t","obj","Error","serializeOramaInstance","db","raw","idStore","internalDocumentIDStore","internalIdToId","docs","count","docKeys","doc","docFields","index","indexes","indexKeys","cKey","ntdi","searchProps","searchableProperties","propsWithTypes","searchablePropertiesWithTypes","propsKeys","avgFL","avgFieldLength","avgKeys","fieldLengths","fieldData","fieldDataKeys","language","pinningRules","pinning","rules","ruleId","rule","getBuffer","deserializeOramaInstance","buffer","version","idStoreLen","docsLength","arrayInfo","indexCount","dLen","cLen","ntdiLen","idsLen","searchPropLen","propsWithTypesLen","avgFLLen","fieldLengthsLen","dataLen","vectorIndexes","pinningRulesLen","sorting","cloneRawData"],"mappings":"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"}