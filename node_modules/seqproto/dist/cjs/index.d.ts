export type StrictArrayBuffer = ArrayBuffer & {
    buffer?: undefined;
};
export interface Ser {
    index: number;
    buffer: ArrayBuffer;
    uint32Array: Uint32Array;
    float32Array: Float32Array;
    reset: () => void;
    getBuffer: () => StrictArrayBuffer;
    serializeBoolean: (b: boolean) => void;
    serializeUInt32: (n: number) => void;
    serializeFloat32: (n: number) => void;
    serializeNumber: (n: number) => void;
    serializeString: (str: string) => void;
    serializeArray: <T>(arr: T[], serialize: (ser: Ser, t: T) => void) => void;
    serializeIterable: <T>(iterable: Iterable<T>, serialize: (ser: Ser, t: T) => void) => void;
    serializeIndexableArray: <T>(arr: T[], serialize: (ser: Ser, t: T) => void) => void;
    unsafeSerializeUint32Array: (buffer: Uint32Array) => void;
}
export interface Des {
    index: number;
    buffer: StrictArrayBuffer;
    uint32Array: Uint32Array;
    float32Array: Float32Array;
    setBuffer: (buffer: StrictArrayBuffer, byteOffset?: number, byteLength?: number) => void;
    deserializeBoolean: () => boolean;
    deserializeUInt32: () => number;
    deserializeFloat32: () => number;
    deserializeNumber: () => number;
    deserializeString: () => string;
    deserializeArray: <T>(deserialize: (des: Des) => T) => T[];
    deserializeIterable: <T>(deserialize: (des: Des) => T) => Iterable<T>;
    unsafeDeserializeUint32Array: () => Uint32Array;
    getArrayElements: <T>(indexes: number[], deserialize: (des: Des, start: number, end: number) => T) => T[];
}
interface CreateSerOption {
    bufferSize?: number;
}
export declare function createSer({ bufferSize }?: CreateSerOption): Ser;
export declare function createDes(buffer: StrictArrayBuffer): Des;
export {};
