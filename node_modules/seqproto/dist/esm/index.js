const TYPE_FLOAT = 0;
const TYPE_UINT32 = 1;
const TYPE_INT32 = 2;
const POW_2_32 = 2 ** 32;
export function createSer({ bufferSize } = {}) {
    const size = bufferSize !== null && bufferSize !== void 0 ? bufferSize : 2 ** 24;
    if (size >= POW_2_32) {
        throw new Error('bufferSize option must be strictly less than 2 ** 32');
    }
    const buffer = new ArrayBuffer(size);
    return {
        index: 0,
        buffer,
        uint32Array: new Uint32Array(buffer),
        float32Array: new Float32Array(buffer),
        reset: function () { this.index = 0; },
        serializeBoolean,
        serializeUInt32,
        serializeFloat32,
        serializeNumber,
        serializeString,
        serializeArray,
        serializeIterable,
        serializeIndexableArray,
        unsafeSerializeUint32Array,
        getBuffer: function () { return this.buffer.slice(0, this.index * 4); }
    };
}
export function createDes(buffer) {
    const n32 = Math.floor(buffer.byteLength / 4);
    return {
        index: 0,
        buffer,
        uint32Array: new Uint32Array(buffer, 0, n32),
        float32Array: new Float32Array(buffer, 0, n32),
        setBuffer: function (buffer, byteOffset, byteLength) {
            if (typeof byteOffset === 'number' && typeof byteLength === 'number') {
                this.index = Math.floor(byteOffset / 4);
                const n32 = this.index + Math.ceil(byteLength / 4);
                this.buffer = buffer;
                this.uint32Array = new Uint32Array(buffer, 0, n32);
                this.float32Array = new Float32Array(buffer, 0, n32);
                return;
            }
            const n32 = Math.floor(buffer.byteLength / 4);
            this.buffer = buffer;
            this.index = 0;
            this.uint32Array = new Uint32Array(buffer, 0, n32);
            this.float32Array = new Float32Array(buffer, 0, n32);
        },
        deserializeBoolean,
        deserializeUInt32,
        deserializeFloat32,
        deserializeNumber,
        deserializeString,
        deserializeArray,
        deserializeIterable,
        getArrayElements,
        unsafeDeserializeUint32Array
    };
}
function serializeBoolean(b) {
    this.uint32Array[this.index++] = b ? 1 : 0;
}
function deserializeBoolean() {
    return this.uint32Array[this.index++] === 1;
}
function serializeUInt32(n) {
    this.uint32Array[this.index++] = n;
}
function deserializeUInt32() {
    return this.uint32Array[this.index++];
}
function serializeFloat32(n) {
    this.float32Array[this.index++] = n;
}
function deserializeFloat32() {
    return this.float32Array[this.index++];
}
function serializeNumber(n) {
    // If it's not an integer
    if (n % 1 !== 0) {
        this.uint32Array[this.index++] = TYPE_FLOAT;
        this.serializeFloat32(n);
    }
    else if (n >= 0) {
        this.uint32Array[this.index++] = TYPE_UINT32;
        this.serializeUInt32(n);
    }
    else {
        this.uint32Array[this.index++] = TYPE_INT32;
        this.uint32Array[this.index++] = POW_2_32 + n;
    }
}
function deserializeNumber() {
    const type = this.uint32Array[this.index++];
    if (type === TYPE_FLOAT) {
        return this.deserializeFloat32();
    }
    else if (type === TYPE_UINT32) {
        return this.deserializeUInt32();
    }
    else if (type === TYPE_INT32) {
        return this.uint32Array[this.index++] - POW_2_32;
    }
    else {
        throw new Error('Unknown type');
    }
}
const textEncoder = new TextEncoder();
function serializeString(str) {
    const r = textEncoder.encodeInto(str, new Uint8Array(this.buffer, (this.index + 1) * 4));
    this.uint32Array[this.index] = r.written;
    this.index += Math.ceil(r.written / 4) + 1;
}
const textDecoder = new TextDecoder();
function deserializeString() {
    const len = this.uint32Array[this.index++];
    const decoded = textDecoder.decode(new Uint8Array(this.buffer, this.index * 4, len));
    this.index += Math.ceil(len / 4);
    return decoded;
}
function serializeArray(arr, serialize) {
    const len = arr.length;
    this.serializeUInt32(len);
    for (let i = 0; i < len; i++) {
        serialize(this, arr[i]);
    }
}
function deserializeArray(deserialize) {
    const len = this.deserializeUInt32();
    const arr = new Array(len);
    for (let i = 0; i < len; i++) {
        arr[i] = deserialize(this);
    }
    return arr;
}
function serializeIterable(iterable, serialize) {
    // Keep space for the length
    const currentIndex = this.index++;
    let n = 0;
    for (const t of iterable) {
        n++;
        serialize(this, t);
    }
    this.uint32Array[currentIndex] = n;
}
function deserializeIterable(deserialize) {
    const len = this.deserializeUInt32();
    const aGeneratorObject = (function* (des) {
        for (let i = 0; i < len; i++) {
            yield deserialize(des);
        }
    })(this);
    return {
        [Symbol.iterator]() {
            return aGeneratorObject;
        }
    };
}
function unsafeSerializeUint32Array(arr) {
    const length = Math.ceil(arr.byteLength / 4);
    this.uint32Array[this.index++] = length;
    this.uint32Array.set(arr, this.index);
    this.index += length;
}
function unsafeDeserializeUint32Array() {
    const byteLength = this.uint32Array[this.index++];
    const d = new Uint32Array(this.buffer, this.index * 4, byteLength);
    this.index += byteLength;
    return d;
}
function serializeIndexableArray(arr, serialize) {
    const l = arr.length;
    this.uint32Array[this.index++] = l;
    let indexOffsets = this.index;
    // Skip the length of the array twice
    // to store the offset + length of the array element
    this.index += l * 2;
    for (let i = 0; i < l; i++) {
        const offsetStart = this.index;
        serialize(this, arr[i]);
        const offsetEnd = this.index;
        this.uint32Array[indexOffsets++] = offsetStart;
        this.uint32Array[indexOffsets++] = offsetEnd - offsetStart;
    }
}
function getArrayElements(indexes, deserialize) {
    const currentIndex = this.index + 1;
    const l = indexes.length;
    const arr = new Array(l);
    for (let i = 0; i < l; i++) {
        const indexOffset = currentIndex + indexes[i] * 2;
        const start = this.uint32Array[indexOffset];
        const end = this.uint32Array[indexOffset + 1];
        arr[i] = deserialize(this, start * 4, end);
    }
    return arr;
}
